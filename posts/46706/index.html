<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ityoung">





<title>Redis从零基础到入门 | 谢谢你这么好看还来访问我的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="谢谢你这么好看还来访问我的博客" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">首页</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/link">友链</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">首页</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/link">友链</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开目录</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">到达尾部</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Redis从零基础到入门</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Ityoung</a>
                    

                    
                        <span class="post-time">
                        发布时间: <a href="#">2020-12-21&nbsp;&nbsp;23:32:14</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/Redis/">Redis</a>
                            
                        </span>
                    
					<br/>
					<!-- 开始添加字数统计-->
					
						

<span class="post-time">
  <span class="post-meta-item-icon">
	<i class="fa fa-keyboard-o"></i>
	<span class="post-meta-item-text">  字数统计: </span>
	<!-- 安装插件npm install hexo-wordcount --save -->
	<span class="post-count" style="color: #2d96bd">13.8k</span>字
  </span>
</span>

<span class="post-time">
  <span class="post-meta-item-icon">
	<i class="fa fa-hourglass-half"></i>
	<span class="post-meta-item-text">  阅读时长: </span>
	<span class="post-count" style="color: #2d96bd">53</span>分
  </span>
</span>

					
					<!-- 添加完成 -->
                </div>
            
			<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> visits</span>
			
        </header>

        <div class="post-content">
            <h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><h3 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h3><blockquote>
<p><strong>1.单机Mysql的年代!</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171537.png" alt="image-20201126162435674"></p>
<p>90年代,一个基本的网站访问量一般不会太大,单个数据库完全足够!</p>
<p>那个时候,更多的失去使用静态网页 Html~ 服务器根本没有太大的压力!</p>
<p>思考一下,这种情况下:整个网站的瓶颈是什么?</p>
<ol>
<li>数据量如果太大,一个机器根本放不了</li>
<li>数据的索引(B+ Tree),一个机器内存也放不下</li>
<li>访问量(读写混合),一个服务器承受不了!</li>
</ol>
<blockquote>
<p><strong>2.Memcached(缓存)+Mysql+垂直拆分(读写分离)</strong></p>
</blockquote>
<p>网站80%的情况都是在读,每次都要查询数据库的话就十分的麻烦!所以我们希望减轻数据库的压力,我们可以使用缓存来保证效率</p>
<p>发展过程: 优化数据结构和索引—&gt;文件缓存(IO)—&gt;Memcached(当时最热门的技术)</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171550.png" alt="image-20201126163132879"></p>
<blockquote>
<p><strong>3.分库分表+水平拆分+Mysql集群</strong></p>
</blockquote>
<p><strong>技术和业务在发展的同时,对人的要求也越来越高</strong></p>
<p><code>本质:数据库(读,写)</code></p>
<p>早些年MyISAM: 表锁,十分影响效率! 高并发下就会出现严重的锁问题</p>
<p>早些年Innodb: 行锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171635.png" alt="image-20201126164233511"></p>
<blockquote>
<p><strong>4</strong>.<strong>当今年代</strong></p>
</blockquote>
<p>Mysql等关系型数据库就不够用了! 数据量很多,变化很快</p>
<p>Mysql有的使用它来存储一些比较大的文件,博客,图片!数据库表很大,效率就低了!如果有一种数据库专门处理这种数据,Mysql压力就变得十分小</p>
<blockquote>
<p><strong>目前一个基本的互联网项目</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171710.png" alt="image-20201126165917816"></p>
<p><strong>每一个功能都是用单独的服务器</strong></p>
<blockquote>
<p><strong>为什么要用NoSQL!</strong></p>
</blockquote>
<p>用户的个人信息,社交网络,地理位置.用户自己产生的数据,用户日志等等爆发式增长.</p>
<p>这个时候我们就需要使用NoSQL数据库,NoSQL可以很好地解决这些问题</p>
<h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><blockquote>
<p><strong>NoSQL</strong></p>
</blockquote>
<p>NoSQL = Not Only Sql (不仅仅是SQL)</p>
<p>关系型数据库: 表格,行,列</p>
<p>泛指非关系型数据库的,随着web2.0互联网的诞生! 传统的关系型数据库很难应对web2.0时代!尤其是超大规模的高并发的社区!暴露出来很多难以克服的问题,NoSQL在当今大数据环境下的发展十分的迅速,Redis是最快的一个,而且也是当下时代必须要掌握的一项技术!</p>
<blockquote>
<p><strong>NoSQL的特点</strong></p>
</blockquote>
<p>1.方便扩展(数据之间没有关系,很好扩展)</p>
<p>2.大数据量高性能(Redis一秒写8万次 ,读取11万次,NoSQL的缓存,是一种细粒度的缓存,性能会比较高)</p>
<p>3.数据类型是多样型的!(不需要事先设计数据库!随取随用!如果数据量十分大的表,很多人都无法设计)</p>
<p>4.传统的RDBMS和NoSQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">-结构化组织</span><br><span class="line">-数据和关系都存在单独的表中</span><br><span class="line">-操作操作数据定义语言</span><br><span class="line">-严格的一致性</span><br><span class="line">-基础的事务</span><br><span class="line">-....</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">-不仅仅是数据</span><br><span class="line">-没有固定的查询语言</span><br><span class="line">-键值对存储,列存储,文档存储,图形数据库(社交关系)</span><br><span class="line">-最终一致性</span><br><span class="line">-CAP定理 和 BASE定理(异地多活!)</span><br><span class="line">-三高问题 高性能,高可用,高可扩</span><br><span class="line">-...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>了解3V和3高</strong></p>
</blockquote>
<p>大数据时代的3V:主要是描述问题的:</p>
<ol>
<li>海量的Volume</li>
<li>多样的Variety</li>
<li>实时的Velocity</li>
</ol>
<p>大数据时代的3高:主要是对程序的要求</p>
<ol>
<li>高并发</li>
<li>高可拓 (随时水平拆分,极其不够了,可以扩展)</li>
<li>高性能</li>
</ol>
<h3 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h3><hr>
<h4 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对:"></a>KV键值对:</h4><ul>
<li>新浪:Redis</li>
<li>美团:Redis+Tair</li>
<li>阿里,百度:Redis+memcache</li>
</ul>
<h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><ul>
<li>MongoDB(一般必须要掌握)<ul>
<li>MongDB是一个基于分布式文件存储的数据库,C++编写,主要用于处理大量的文档</li>
<li>MongoDB是一个结语关系型数据库和非关系数据库中间的产品!MongoDB是非关系数据库种功能最丰富的,最像关系型数据库的!</li>
</ul>
</li>
<li>CouchDB</li>
</ul>
<h4 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h4><ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<h4 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a>图关系数据库</h4><ul>
<li>他不是存图像,放得是一写关系,比如:朋友圈社交网络</li>
<li>Neo4j,InfoGrid</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231193141.png" alt="image-20201231193141004"></p>
<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Redis是什么?</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务!</p>
<p>是一个开源的使用ANSI <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API!</p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步.</p>
<p>免费和开源!是当下最热门的NoSQL技术之一!也被人们称为结构化数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171800.png" alt="image-20201126234119042"></p>
<blockquote>
<p><strong>Redis能干嘛?</strong></p>
</blockquote>
<ol>
<li>内存存储,持久化,内存中是断电即失,所以说持久化很重要(rdb,aof)</li>
<li>效率高,可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器,计数器(浏览量)</li>
<li>……</li>
</ol>
<blockquote>
<p><strong>特性</strong></p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ol>
<blockquote>
<p>学习中需要的东西</p>
</blockquote>
<ul>
<li>Redis官网<a target="_blank" rel="noopener" href="http://www.redis.io/">www.redis.io</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/">redis中文官方网站</a></li>
</ul>
<p>注意windows版需要在github上下载(停更好久了!)</p>
<p><code>Redis推荐都是在Linux服务商搭建的,我们是基于Linux学习!</code></p>
<h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ol>
<li>下载安装包<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis/releases">dmajkic/redis: Redis key-value store (Win32 / Win64 port) (github.com)</a></li>
<li>解压就可以直接使用</li>
<li>里面有一个服务端 redis-server.exe 一个客户端redis-cli.exe 还有一个测试速度的redis-benchmark.exe</li>
<li>打开服务端 就可以在客户端使用了</li>
</ol>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ol>
<li>下载安装包 </li>
<li>解压Redis的安装包!程序一般放在/opt中 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar-zxvf redis </span><br></pre></td></tr></table></figure>
<p>3.安装基本的环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">###提示 redis6需要升级gcc</span></span><br><span class="line"><span class="comment">#升级到 5.3及以上版本</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"> </span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"> </span><br><span class="line"><span class="comment">#注意：scl命令启用只是临时的，推出xshell或者重启就会恢复到原来的gcc版本。</span></span><br><span class="line"><span class="comment">#如果要长期生效的话，执行如下：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在make测试一下</span><br><span class="line"></span><br><span class="line">最后make install 一下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171808.png" alt="image-20201127190207979"></p>
<p>4.redis的默认安装路劲<code>usr/local/bin</code></p>
<p>5.将redis配合文件复制到 第4步的路径中 cp /opt/redis-6.0.6/redis.conf jconfig</p>
<p>6.redis默认不是后台启动的,修改配置文件!</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171814.png" alt="image-20201127191543541"></p>
<p>7.启动Redis服务!</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171849.png" alt="image-20201127191820757"></p>
<p>8.通过redis-cli连接测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171816.png" alt="image-20201127192108868"></p>
<p>9.查看redis的进程是否开启 ps -ef|grep redis</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171854.png" alt="image-20201127192308310"></p>
<p>10.如何关闭redis服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171858.png" alt="image-20201127192456057"></p>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><hr/>

<p><strong>redis-benchmark</strong>是一个压力测试工具!</p>
<p>官方自带的性能测试工具</p>
<hr/>

<p>redis-benchmark命令参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171902.png" alt="image-20201128001251490"></p>
<p>我们来简单测试一下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试: 100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>
<hr>


<p>如何查看这些分析呢?</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171911.png" alt="image-20201128003145063"></p>
<h3 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>Redis有16个数据库(可以再配置文件中查看)<ul>
<li>默认使用的是第0个</li>
</ul>
</li>
<li>如何切换数据库<code>select index</code>(数据库编号)</li>
<li>查看数据库大小<code>DBSIZE</code></li>
<li>查看数据所有的key<code>keys *</code></li>
<li>清除当前数据库<code>flushdb</code></li>
<li>清空所有数据库<code>flushall</code></li>
<li>判断当前的key是否存在<code>EXISTS</code></li>
<li>移除当前的key<code>MOVE</code></li>
<li>设置过期时间 <code>EXPISE</code> s</li>
<li>查看当前key的剩余时间 <code>ttl</code></li>
<li>查看当前key的类型<code>type</code></li>
</ul>
<h4 id="Redis是单线程的"><a href="#Redis是单线程的" class="headerlink" title="Redis是单线程的!"></a>Redis是单线程的!</h4><p>明白Redis是很快的,官方表示,Redis是基于内存操作的,CPU不是Redis的性能瓶颈,Redis的瓶颈是根据机器的内存和网络的带宽,所以就使用单线程了!</p>
<h4 id="Redis为什么单线程还这么快"><a href="#Redis为什么单线程还这么快" class="headerlink" title="Redis为什么单线程还这么快?"></a>Redis为什么单线程还这么快?</h4><ol>
<li>误区1:高性能的服务器一定是多线程的?</li>
<li>误区2:多线程(CPU上下文会切换!)一定比单线程效率高!</li>
</ol>
<p>核心:redis是将所有的数据全部放在内存中,所以单线程去操作失效率最高的,多线程的上下文切换是耗时的操作!!! 对于内存系统来说,如果没有上下文切换是效率最高的!多次的读写在同一个cpu上,在内存情况下,这个就是最佳的方案!</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件</code>。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><hr>


<ul>
<li>如何切换数据库<code>select index</code>(数据库编号)</li>
<li>查看数据库大小<code>DBSIZE</code></li>
<li>查看数据所有的key<code>keys *</code></li>
<li>清除当前数据库<code>flushdb</code></li>
<li>清空所有数据库<code>flushall</code></li>
<li>判断当前的key是否存在<code>EXISTS</code></li>
<li>移除当前的key<code>MOVE</code></li>
<li>设置过期时间 <code>EXPISE</code> s</li>
<li>查看当前key的剩余时间 <code>ttl</code></li>
<li>查看当前key的类型<code>type</code></li>
</ul>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><hr>


<ul>
<li>追加字符串 <code>append</code></li>
<li>获取字符串长度<code>strlen</code></li>
<li>自增1 <code>incr</code></li>
<li>自减1 <code>decr</code></li>
<li>自增并设置步长 <code>incrby key 步长</code></li>
<li>自减并设置步长<code>decrby key 步长</code></li>
<li>获取指定范围的字符串 <code>getrange</code></li>
<li>替换指定开始的字符串<code>setrange key 开始位置 更改的值</code></li>
<li>设置key并附加过期时间 <code>setex</code> (set with expise )</li>
<li>设置key只有在不存在的时候成功<code>setnx</code>(set if not exist)</li>
<li>批量设置<code>mset</code></li>
<li>批量获取<code>mget</code></li>
<li><code>如何设置对象</code><ul>
<li><code>set user:1 &#123;name:zhangsan,age:3&#125;</code>  设置一个user id为1的对象值为json数组</li>
<li>巧妙的设计user:{id}:{filed}<ul>
<li> <code>mset user:1:name zhangsan user:1:age 3</code></li>
<li> <code>mget user:1:name user:1:age</code></li>
</ul>
</li>
</ul>
</li>
<li>先get然后在set <code>getset</code> <ul>
<li>如果原先不存在则返回nil 在设置输入的值</li>
<li>如果原先存在则先返回<code>原先的值</code>,并设置新的值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>APPEND key value</code></td>
<td>向指定的key的value后追加字符串</td>
<td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td>
</tr>
<tr>
<td><code>DECR/INCR key</code></td>
<td>将指定key的value数值进行+1/-1(仅对于数字)</td>
<td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td>
</tr>
<tr>
<td><code>INCRBY/DECRBY key n</code></td>
<td>按指定的步长对数值进行加减</td>
<td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key n</code></td>
<td>为数值加上浮点型数值</td>
<td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td>
</tr>
<tr>
<td><code>STRLEN key</code></td>
<td>获取key保存值的字符串长度</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td>
</tr>
<tr>
<td><code>GETRANGE key start end</code></td>
<td>按起止位置获取字符串（闭区间，起止位置都取）</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td>
</tr>
<tr>
<td><code>SETRANGE key offset value</code></td>
<td>用指定的value 替换key中 offset开始的值</td>
<td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td>
</tr>
<tr>
<td><code>GETSET key value</code></td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
<td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td>
</tr>
<tr>
<td><code>SETNX key value</code></td>
<td>仅当key不存在时进行set</td>
<td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td>
</tr>
<tr>
<td><code>SETEX key seconds value</code></td>
<td>set 键值对并设置过期时间</td>
<td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td>
</tr>
<tr>
<td><code>MSET key1 value1 [key2 value2..]</code></td>
<td>批量set键值对</td>
<td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td>
</tr>
<tr>
<td><code>MSETNX key1 value1 [key2 value2..]</code></td>
<td>批量设置键值对，仅当参数中所有的key都不存在时执行</td>
<td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td>
</tr>
<tr>
<td><code>MGET key1 [key2..]</code></td>
<td>批量获取多个key保存的值</td>
<td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td>
</tr>
<tr>
<td><code>PSETEX key milliseconds value</code></td>
<td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td>
<td></td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td>
<td></td>
</tr>
</tbody></table>
<p>String</p>
<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><hr>


<p>基本数据类型,列表!</p>
<p>在redis里面我们可以把list玩成,栈 队列 阻塞队列</p>
<p><code>所有的list命令都是L开头的</code></p>
<ul>
<li>将一个值或多个值,插入到列表头部<code>LPUSH</code></li>
<li>将一个值或多个值,插入到列表的尾部<code>RPUSH</code></li>
<li>将一个值或多个值,从列表头部移除<code>LPOP</code></li>
<li>将一个值或多个值,从列表尾部移除<code>RPOP</code></li>
<li>获取list的值<code>LRANGE</code> <code>0~--1表示全部</code></li>
<li>获取list的某一个值<code>LINDEX</code>  <code>LINDEX key index</code></li>
<li>返回列表的长度<code>LLEN</code></li>
<li>在list中移除指定的个数 value值 <code>LREM</code></li>
<li>截断list<code>LTRIM</code>  </li>
<li><code>组合命令</code><ul>
<li>移除列表的最后一个元素,将他移动到新的列表中<code>RPOPLPUSH</code></li>
</ul>
</li>
<li>将列表中指定下标的值替换为另外一个值,更新操作 <code>LSET``如果不存在这个下标的list将报错</code></li>
<li>判断list是否存在 <code>EXISTS</code></li>
<li>列表的插入操作<code>LINSERT key before|after 列表中哪一个元素 插入什么元素</code></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH/RPUSH key value1[value2..]</code></td>
<td>从左边/右边向列表中PUSH值(一个或者多个)。</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>获取list 起止元素<code>（索引从左往右 递增）</code></td>
</tr>
<tr>
<td><code>LPUSHX/RPUSHX key value</code></td>
<td>向已存在的列名中push值（一个或者多个）</td>
</tr>
<tr>
<td>`LINSERT key BEFORE</td>
<td>AFTER pivot value`</td>
</tr>
<tr>
<td><code>LLEN key</code></td>
<td>查看列表长度</td>
</tr>
<tr>
<td><code>LINDEX key index</code></td>
<td>通过索引获取列表元素</td>
</tr>
<tr>
<td><code>LSET key index value</code></td>
<td>通过索引为元素设值</td>
</tr>
<tr>
<td><code>LPOP/RPOP key</code></td>
<td>从最左边/最右边移除值 并返回</td>
</tr>
<tr>
<td><code>RPOPLPUSH source destination</code></td>
<td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td>
</tr>
<tr>
<td><code>LTRIM key start end</code></td>
<td>通过下标截取指定范围内的列表</td>
</tr>
<tr>
<td><code>LREM key count value</code></td>
<td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td>
</tr>
<tr>
<td><code>BLPOP/BRPOP key1[key2] timout</code></td>
<td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td><code>BRPOPLPUSH source destination timeout</code></td>
<td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
</tbody></table>
<blockquote>
<p>小结</p>
</blockquote>
<ol>
<li>他实际上是一个链表:before Node after, left right都可以插入值</li>
<li>如果key不存在,则新建链表</li>
<li>如果key存在,则可以对链表进行操作</li>
<li>如果移除了所有值,就是空链表,就是代表不存在</li>
<li>在两边插入或者改动值效率最高,中间元素相对来说效率会低一些!</li>
</ol>
<p><code>消息排队 消息队列 (LPUSH RPOP)左进右出 ,栈(LPUSH LPOP)左进左出</code></p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote>
<p>SET 无序不重复集合</p>
</blockquote>
<p> <code>所有命令都是S开头</code></p>
<ul>
<li>set集合中添加值 <code>SADD</code></li>
<li>查看指定set的所有值 <code>SMEMBERS</code></li>
<li>判断set中是否包含指定值 <code>SISMEMBER key value</code></li>
<li>获取set集合中的内容个数 <code>SCARD</code></li>
<li>移除set中的指定元素<code>SREM</code>  SREM myset value</li>
<li>随机抽出指定个数元素<code>SRANDMEMBER key count</code></li>
<li>随机删除一些set集合中的元素 <code>SPOP</code></li>
<li>将一个指定的值,移动到另外一个set集合中<code>SMOVE</code></li>
<li>两个数据集合<ul>
<li>差集 <code>SDIFF key1 key2</code> <code>key1中的差集</code></li>
<li>交集 <code>SINTER</code> <code>共同好友实现</code></li>
<li>并集 <code>SUNION</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member1[member2..]</code></td>
<td>向集合中无序增加一个/多个成员</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>返回集合中所有的成员</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>查询member元素是否是集合的成员,结果是无序的</td>
</tr>
<tr>
<td><code>SRANDMEMBER key [count]</code></td>
<td>随机返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SPOP key [count]</code></td>
<td>随机移除并返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SMOVE source destination member</code></td>
<td>将source集合的成员member移动到destination集合</td>
</tr>
<tr>
<td><code>SREM key member1[member2..]</code></td>
<td>移除集合中一个/多个成员</td>
</tr>
<tr>
<td><code>SDIFF key1[key2..]</code></td>
<td>返回所有集合的差集 key1- key2 - …</td>
</tr>
<tr>
<td><code>SDIFFSTORE destination key1[key2..]</code></td>
<td>在SDIFF的基础上，将结果保存到集合中<code>(覆盖)</code>。不能保存到其他类型key噢！</td>
</tr>
<tr>
<td><code>SINTER key1 [key2..]</code></td>
<td>返回所有集合的交集</td>
</tr>
<tr>
<td><code>SINTERSTORE destination key1[key2..]</code></td>
<td>在SINTER的基础上，存储结果到集合中。覆盖</td>
</tr>
<tr>
<td><code>SUNION key1 [key2..]</code></td>
<td>返回所有集合的并集</td>
</tr>
<tr>
<td><code>SUNIONSTORE destination key1 [key2..]</code></td>
<td>在SUNION的基础上，存储结果到及和张。覆盖</td>
</tr>
<tr>
<td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td>
<td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td>
</tr>
</tbody></table>
<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><blockquote>
<p>Map集合,key-map!这个key的值就是一个map集合.</p>
</blockquote>
<p><code>所有命令都是H开头的</code></p>
<ul>
<li>在hash中设置值 <code>hset </code>  <code>hset myhash field1 jiuyuesheng</code></li>
<li>在hash中获取值<code>hget</code>  <code>hget myhash field1</code></li>
<li>在hash中设置多个值 <code>hmset</code> <code> hmset myhash field1 jiuyuesheng field2 lidaben</code></li>
<li>在hash中获取多个值<code>hmget</code>  hmget myhash field1 field2</li>
<li>获取hash所有的值<code>hgetall</code> hgetall myhash</li>
<li>删除hash中指定字段的值 <code>hdel</code> hdel myhash field1</li>
<li>获取hash中的长度 <code>hlen</code></li>
<li>获取所有的hash字段 <code>hkeys</code></li>
<li>获取所有hash值 <code>hvals</code></li>
<li>自增字段<code>incr incrby </code>   <code>hincrby myhash field3 1</code></li>
<li>自减字段 <code>decr decrby</code>  <code>hdecrby myhash field3 1</code></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET key field value</code></td>
<td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td>
</tr>
<tr>
<td><code>HMSET key field1 value1 [field2 value2..]</code></td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td><code>HEXISTS key field</code></td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td><code>HGET key field value</code></td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td><code>HMGET key field1 [field2..]</code></td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取在哈希表key 的所有字段和值</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取哈希表key中所有的字段</td>
</tr>
<tr>
<td><code>HLEN key</code></td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td><code>HDEL key field1 [field2..]</code></td>
<td>删除哈希表key中一个/多个field字段</td>
</tr>
<tr>
<td><code>HINCRBY key field n</code></td>
<td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td>
</tr>
<tr>
<td><code>HINCRBYFLOAT key field n</code></td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td>
</tr>
<tr>
<td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<blockquote>
<p>hash变更的数据 user name age,尤其是用户信息,经常变更信息,<code>hash更适合对象的存储,string更适合字符串存储!</code></p>
<p>hset user:1 name jiuyuesheng age 18</p>
</blockquote>
<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset  (有序集合)"></a>Zset  (有序集合)</h3><blockquote>
<p>在set的集合上,增加了一个值,</p>
<p>set k1 v1   zset k1 score1 v1</p>
<p><code>所有命令以Z开头</code></p>
</blockquote>
<ul>
<li>添加一个值 <code>zadd</code>  zadd myset 1 on</li>
<li>添加多个值 zadd myset 2 two 3 three</li>
<li>通过score<strong>从小到大</strong>排序 <code>zrangbyscore</code>   zrangbyscore key -inf +inf withscore(<code>数据带score</code>) </li>
<li>通过score从大到小排序 <code>zrevrangbyscore</code></li>
<li>获取指定区间的数量 <code>zcount</code></li>
<li>其余和SET类型一致</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member1 [score2 member2]</code></td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>计算在有序集合中指定区间score的成员数</td>
</tr>
<tr>
<td><code>ZINCRBY key n member</code></td>
<td>有序集合中对指定成员的分数加上增量 n</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td><code>ZRANGE key start end</code></td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYLEX key min max</code></td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>通过分数返回有序集合指定区间内的成员<code>-inf 和 +inf分别表示最小最大值，只支持开区间()</code></td>
</tr>
<tr>
<td><code>ZLEXCOUNT key min max</code></td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td><code>ZREM key member1 [member2..]</code></td>
<td>移除有序集合中一个/多个成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYLEX key min max</code></td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYRANK key start stop</code></td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYSCORE key min max</code></td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td><code>ZREVRANGE key start end</code></td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td><code>ZREVRANGEBYSCORRE key max min</code></td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td><code>ZREVRANGEBYLEX key max min</code></td>
<td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td>
</tr>
<tr>
<td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<p><code>可以使用的案例</code></p>
<ol>
<li>带权重的消息 1 普通消息 2重要消息</li>
<li>排行榜 Top N</li>
<li>set排序 班级成绩表 员工工资表</li>
</ol>
<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><blockquote>
<p>朋友的定位,附近的人,打车距离计算  Redis的Geo在Redis3,2就推出了!这个功能可以推算地理位置的信息,两地之间的距离,方圆几里的人</p>
</blockquote>
<hr>


<ul>
<li><p>添加城市的经纬度<code>geoadd</code>  <code>geoadd china:city 116.40 39.90 beijing(经度 纬度  名称)</code></p>
<ul>
<li>两级无法直接添加,我们一般会下载城市数据数据,通过Java程序一次性导入</li>
</ul>
</li>
<li><p>获取一个或多个指定城市的经度纬度 <code>geopos</code> <code>geopos china:city beijing</code></p>
</li>
<li><p>计算两地的距离(一个位置错误,则返回nil,可以设置返回的距离单位) <code>geodist</code> <code>geodist china:city beijing shanghai km</code></p>
</li>
<li><p>以给定的经纬度为中心,找出某一半径内的元素<code>georadius</code> <code>georadius china:city 自己的经纬度 距离 距离单位 withdist withcoord count num</code></p>
</li>
<li><p>找出指定元素周围的其他元素 <code>georadiusbymember``georadiusbymember china:city beijing 5000 km</code></p>
<blockquote>
<p>GEO底层的实现原理是Zset!我们可以使用Zset命令来操作geo </p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td>
<td>将具体经纬度的坐标存入一个有序集合</td>
</tr>
<tr>
<td><code>geopos key member [member..]</code></td>
<td>获取集合中的一个/多个成员坐标</td>
</tr>
<tr>
<td><code>geodist key member1 member2 [unit]</code></td>
<td>返回两个给定位置之间的距离。默认以米作为单位。</td>
</tr>
<tr>
<td>`georadius key longitude latitude radius m</td>
<td>km</td>
</tr>
<tr>
<td><code>GEORADIUSBYMEMBER key member radius...</code></td>
<td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td>
</tr>
<tr>
<td><code>geohash key member1 [member2..]</code></td>
<td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td>
</tr>
</tbody></table>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>什么是基数? </p>
</blockquote>
<p>不重复的元素</p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis Hyperloglog 基数统计的算法!</p>
<p>优点:占用的内存是固定的,2^64不同的元素的技术.只需要消耗12kb的内存!如果从内存的角度来比较我们首选Hyperloglog.</p>
<p><strong>网页的UV(一个人访问的一个网站多次,但是还是算作一次)</strong></p>
<p>Hyperloglog有0.81%的误差率! 统计UV任务,我们可以忽略不计!</p>
<ul>
<li>创建第一组元素<code>PFadd``PFadd mykey  元素</code></li>
<li>合并两组元素<code>PFMERGE</code> <code>PFMERGE mykey1 mykey2</code></li>
<li>查看一组元素的不重复的数量 <code>PFCOUNT</code>  <code>PFCOUNT mykey1</code></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PFADD key element1 [elememt2..]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>PFCOUNT key [key]</code></td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><blockquote>
<p>位存储 <code>一字节=8位</code></p>
</blockquote>
<p>统计用户信息:活跃 不活跃;登录 未登录;只有两种状态;</p>
<p>Bitmap位图,数据结构!都是操作二进制来进行记录, 0  1;</p>
<p><strong>应用场景</strong></p>
<p>签到统计、状态统计</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbit key offset value</code></td>
<td>为指定key的offset位设置值</td>
</tr>
<tr>
<td><code>getbit key offset</code></td>
<td>获取offset位的值</td>
</tr>
<tr>
<td><code>bitcount key [start end]</code></td>
<td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td>
</tr>
<tr>
<td><code>bitop operration destkey key[key..]</code></td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
</tr>
<tr>
<td><code>BITPOS key bit [start] [end]</code></td>
<td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用bitmaps来记录一周的打卡记录</span></span><br><span class="line"><span class="comment">#设置每一天的打卡记录</span></span><br><span class="line">setbit sign 0 0</span><br><span class="line">setbit sign 1 1</span><br><span class="line">setbit sign 2 0</span><br><span class="line">setbit sign 3 1</span><br><span class="line">setbit sign 4 1</span><br><span class="line">setbit sign 5 1</span><br><span class="line">setbit sign 6 0</span><br><span class="line"><span class="comment">#获取某一天是否打卡</span></span><br><span class="line">getbit sign index</span><br><span class="line"><span class="comment">#统计打卡的天数</span></span><br><span class="line">bitcount sign  --&gt; 4</span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="Redis事务的概念："><a href="#Redis事务的概念：" class="headerlink" title="Redis事务的概念："></a><strong>Redis事务的概念：</strong></h3><p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p><code>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</code>　　</p>
<h3 id="Redis事务没有隔离级别的概念："><a href="#Redis事务没有隔离级别的概念：" class="headerlink" title="Redis事务没有隔离级别的概念："></a><strong>Redis事务没有隔离级别的概念：</strong></h3><p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<h3 id="Redis不保证原子性："><a href="#Redis不保证原子性：" class="headerlink" title="Redis不保证原子性："></a><strong>Redis不保证原子性：</strong></h3><p>　　Redis中，<code>单条命令是原子性执行的，但事务不保证原子性</code>，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3 id="Redis事务的三个阶段："><a href="#Redis事务的三个阶段：" class="headerlink" title="Redis事务的三个阶段："></a><strong>Redis事务的三个阶段：</strong></h3><ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<h3 id="Redis事务相关命令："><a href="#Redis事务相关命令：" class="headerlink" title="Redis事务相关命令："></a><strong>Redis事务相关命令：</strong></h3><ul>
<li>　　<code>watch</code> key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</li>
<li>　　<code>multi</code> : 标记一个事务块的开始（ queued ）</li>
<li>　　<code>exec </code>: 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</li>
<li>　　<code>discard</code> : 取消事务，放弃事务块中的所有命令</li>
<li>　　<code>unwatch </code>: 取消watch对所有key的监控</li>
</ul>
<hr>
### 一些事务的案例:解决乐观锁问题  (本质就是执行事务之前比较数据的version)



<blockquote>
<p>正常事务</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172046.png" alt="image-20201130211506607"></p>
<blockquote>
<p>放弃事务</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172049.png" alt="image-20201130211525432"></p>
<blockquote>
<p>编译型异常(代码有问题!命令有错),事务中所有的命令都不执行</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172053.png" alt="image-20201130211541544"></p>
<blockquote>
<p>运行时异常(1/0),如果事务队列存在语法性错误,那么执行命令的时候,其他命令的正常执行,错误命令抛出异常</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172059.png" alt="image-20201130211554822"></p>
<blockquote>
<p>解决乐观锁问题</p>
<ul>
<li>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172106.png" alt="image-20201130211713678"></p>
<ul>
<li>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172115.png" alt="1"></p>
<p>一但执行 EXEC 开启事务的执行后，无论事务是否执行成功， WARCH 对变量的监控都将被取消。</p>
<p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>
<p> <strong>总结：</strong></p>
<p>　　watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>
</blockquote>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用java来操作Redis</p>
<blockquote>
<p>jedis:是Redi官方推荐的java连接开发工具!使用java来操作Redis中间件!如果你要是用java来操作redis,我们则需要对jedis十分熟悉!</p>
</blockquote>
<p><code>其中的api接口都是和上面的命令一致</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span> );</span><br><span class="line"></span><br><span class="line">System.out.println(jedis.ping());</span><br></pre></td></tr></table></figure>


<h1 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h1><p>说明:在springboot2.x之后,原来使用的jedis被替换为了lettuce?</p>
<p>jedis:采用的是直连,多个线程操作的话,是不安全的,如果想要避免不安全,使用jedis pool连接池.<code>更像BIO模式!</code></p>
<p>lettuce:采用netty,实例可以在多个线程中进行共享,不存在线程不安全的情况,可以减少线程数据 .<code>更像NIO模式!</code></p>
<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>配置连接</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * RedisTemplate</span></span><br><span class="line"><span class="comment">       * opsForValue 相当于string    操作String类型</span></span><br><span class="line"><span class="comment">       *opsForList   相当于list      操作list类型</span></span><br><span class="line"><span class="comment">       * opsForSet   相当于set       操作set类型</span></span><br><span class="line"><span class="comment">       * opsForHash  相当于Hash      操作Hash类型</span></span><br><span class="line"><span class="comment">       * opsForZset  相当于Zset      操作Zset类型</span></span><br><span class="line"><span class="comment">       * opsForGeo   相当于操作地图的经纬度</span></span><br><span class="line"><span class="comment">       * opsForHyperLogLog    相当于操作基数(不重复的元素)</span></span><br><span class="line"><span class="comment">       * opsForValue.setBit  相当于操作Bitmap</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      redisTemplate.opsForHyperLogLog()</span><br><span class="line">      redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jiuyuesheng&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;listValue&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForList().leftPop(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForSet().pop(<span class="string">&quot;set&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;jiuyuesheng&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;lidaben&quot;</span>,<span class="number">3999</span>);</span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;tangxuan&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">      Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; salarys = redisTemplate.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;salary&quot;</span>, Double.MIN_VALUE, Double.MAX_VALUE);</span><br><span class="line">      Iterator&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; iterator = salarys.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">          ZSetOperations.TypedTuple&lt;String&gt; typedTuple = iterator.next();</span><br><span class="line">          System.out.println(typedTuple.getValue()+<span class="string">&quot;  &quot;</span>+typedTuple.getScore());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiuyuesheng.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jiuyuesheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/2  19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        <span class="comment">//自定义RedisTemplate</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义jackson序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key使用String的序列化方式</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也是用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//value的key使用jackson的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value也是用jackson的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><blockquote>
<p>容量单位不区分大小写，G和GB有区别</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172821.png" alt="image-20201231172820900"></p>
<blockquote>
<p>可以使用 include 组合多个配置问题</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173053.png" alt="image-20201231173053568"></p>
<blockquote>
<p>网络配置</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173115.png" alt="image-20201231173114985"></p>
<blockquote>
<p>日志输出级别</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173712.png" alt="image-20201231173712401"></p>
<blockquote>
<p>日志输出文件</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173736.png" alt="image-20201231173736612"></p>
<blockquote>
<p>持久化规则</p>
</blockquote>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174724.png" alt="image-20201231174724773"></p>
<blockquote>
<p>RDB文件相关</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174744.png" alt="image-20201231174743844"></p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174803.png" alt="image-20201231174803176" style="zoom:150%;" /></p>
<blockquote>
<p>主从复制</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181415.png" alt="image-20201231181415279"></p>
<blockquote>
<p>Security模块中进行密码设置</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181442.png" alt="image-20201231181442156"></p>
<blockquote>
<p>客户端连接相关</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p>
<p><strong>设置方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br></pre></td></tr></table></figure>
<h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p>
<p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p>
<p><strong>3、volatile-random：</strong>随机删除即将过期key</p>
<p><strong>4、allkeys-random：</strong>随机删除</p>
<p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p>
<p><strong>6、noeviction ：</strong> 永不过期，返回错误</p>
<blockquote>
<p>AOF相关部分</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181522.png" alt="image-20201231181522866"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181544.png" alt="image-20201231181544511"></p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>面试和工作持久化都是重点!</p>
<p>Redis是内存数据库,如果不将内存中的数据库状态保存在磁盘中,那么一旦服务器进程退出,服务器的数据库状态也会消失.所以Redis提供了持久化功能</p>
<h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><blockquote>
<p>什么是RDB</p>
</blockquote>
<p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p>
<img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181654.png" alt="RDB"  />

<p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182416.png" alt="image-20201205194054876" style="zoom: 50%;" />

<p>在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,他恢复时是将快照文件直接读入内存里.</p>
<p>Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入一个临时文件中,待持久化过程结束了,在用这个临时文件替换上次持久化恢复好的文件,整个过程中,主进程是不会进行任何io操作的.这就确保了极高的性能.如果需要进行大规模数据恢复,且对于数据恢复的完整性不是非常敏感,那么RDB方式比AOF方式更加的高效.RDB的缺点是最后一次持久化后的数据可能会丢失.</p>
<p><code>RDB保存的文件是dump.rdb</code></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr>
<p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><hr>
<ol>
<li>save的规则满足的情况下，会自动触发rdb原则</li>
<li>执行flushall命令，也会触发我们的rdb原则</li>
<li>退出redis，也会自动产生rdb文件</li>
</ol>
<h5 id="save"><a href="#save" class="headerlink" title="save"></a>save</h5><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<blockquote>
<p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h5><p><code>flushall</code> 命令也会触发持久化 ；</p>
<h5 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h5><p>满足配置条件中的触发条件 ；</p>
<blockquote>
<p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182539.png" alt="image-20201231182539011"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182615.png" alt="image-20201231182614970"></p>
<h5 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h5><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182634.png" alt="image-20201231182634077"></p>
<h5 id="bgsave和save对比"><a href="#bgsave和save对比" class="headerlink" title="bgsave和save对比"></a><strong>bgsave和save对比</strong></h5><table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fock子进程，消耗内存</td>
</tr>
</tbody></table>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ol>
<h3 id="AOF-Append-only-File"><a href="#AOF-Append-only-File" class="headerlink" title="AOF(Append only File)"></a>AOF(Append only File)</h3><p>将我们的所有命令都记录下来,history,恢复的时候就把这个文件全部执行一遍</p>
<blockquote>
<p>什么是AOF</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182641.png" alt="image-20201208005002139" style="zoom:50%;" />

<p>以日志的形式来记录每个写操作,将Redis执行过的所有的指令记录下来(读操作不记录),只许追加文件但不可以改写文件,redis启动之初会读取该文件重新构造数据,换言之,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作.</p>
<p><code>Aof保存的是appendonly.aof文件</code></p>
<p><del>默认不开启,但是更改配置文件重启redis就可以查看bin下的appendonly.aof文件</del></p>
<p>如果这个aof文件有错误,这时候redis是启动不了的,这时候我们就需要使用redis给我们提供的一个工具来修复他<code>redis-check-aof</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重写规则</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184227.png" alt="image-20201208013112876"></p>
<p>当文件大于64mb的时候,会fork一个新的进程来重写我们的aof文件</p>
<blockquote>
<p><strong>优点和缺点</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认是不开启aof模式的,默认使用的是rdb方式持久化,在大多数情况下rdf是够用的</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment">#持久化的文件名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always   #每次修改都会 sync.</span></span><br><span class="line">appendfsync everysec   <span class="comment">#每秒执行一次 sync.</span></span><br><span class="line"><span class="comment"># appendfsync no       #不执行 sync,这时候操作系统自己同步数据,速度是最快的.</span></span><br></pre></td></tr></table></figure>


<p>优点:</p>
<ol>
<li>每一次修改都同步,文件的完整性会更加好!</li>
<li>每秒执行一次,可能会丢失一秒的数据</li>
<li>从不同步,效率最高的.</li>
</ol>
<p>缺点:</p>
<ol>
<li>相对于数据文件来说,aof远远大于rdb,修复的速度也比rdb慢!</li>
<li>aof运行效率也要比rdb慢,所以我们redis默认的配置就是rdb持久化.</li>
</ol>
<h3 id="RDB-和-AOF-对比选择"><a href="#RDB-和-AOF-对比选择" class="headerlink" title="RDB 和 AOF 对比选择"></a>RDB 和 AOF 对比选择</h3><table>
<thead>
<tr>
<th>RDB</th>
<th>AOF</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<h1 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184235.png" alt="image-20201210134451752"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184251.png" alt="image-20201231184251062"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184313.png" alt="image-20201231184313655"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PSUBSCRIBE pattern [pattern..]</code></td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUNSUBSCRIBE pattern [pattern..]</code></td>
<td>退订一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUBSUB subcommand [argument[argument]]</code></td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td><code>PUBLISH channel message</code></td>
<td>向指定频道发布消息</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>订阅给定的一个或多个频道。</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>退订一个或多个频道</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231185737.png" alt="image-20201231185737002"></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li>
<li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li>
<li>多人在线聊天室。</li>
<li>实时消息系统(网站站长给用户发送推荐信息)</li>
</ol>
<p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ol>
<h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p>
<p>查看当前库的信息：<code>info replication</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>
<p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p>
<ul>
<li>端口号</li>
<li>pid文件名</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p>启动单机多服务集群：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231185754.png" alt="image-20201231185754015"></p>
<h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p><code>默认情况下，每台Redis服务器都是主节点；</code>我们一般情况下只用配置从机就好了！</p>
<p>认老大！一主（79）二从（80，81）</p>
<p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192358.png" alt="image-20201231192358079"></p>
<p>然后主机上也能看到从机的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192414.png" alt="image-20201231192414189"></p>
<p>我们这里是使用命令搭建，是暂时的，<code>真实开发中应该在从机的配置文件中进行配置，</code>这样的话是永久的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192431.png" alt="image-20201231192430924"></p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol>
<li><p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure></li>
<li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>更多信息参考博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p>
<p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p>
<p>单机单个哨兵</p>
<p> <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192552.png" alt="image-20201216175931890"></p>
<p>哨兵的作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>多哨兵模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192559.png" alt="image-20201216180033114"></p>
<p>哨兵的核心配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
<ul>
<li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>成功启动哨兵模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192648.png" alt="image-20201231192648527"></p>
<p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192715.png" alt="image-20201231192715625"></p>
<blockquote>
<p>哨兵模式优缺点</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<blockquote>
<p>哨兵模式的全部配置</p>
</blockquote>
<p>完整的哨兵模式配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>
<h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote>
<p>概念</p>
</blockquote>
<p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192757.png" alt="image-20201231192757429"></p>
<p><strong>缓存空对象</strong></p>
<p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192808.png" alt="image-20201231192808689"></p>
<p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote>
<p>概念</p>
</blockquote>
<p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p><strong>设置热点数据永不过期</strong></p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li><p><strong>加互斥锁(分布式锁)</strong></p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>概念</p>
</blockquote>
<p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192821.png" alt="image-20201231192821187"></p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li><p>redis高可用</p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
</li>
<li><p>限流降级</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
</li>
<li><p>数据预热</p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>作者:</span>
                        <span>Ityoung</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>本站链接:</span>
                        <span><a href="http://www.ityoung.xyz/posts/46706/">http://www.ityoung.xyz/posts/46706/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>执照:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
				<!--
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                
				-->
            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/NoSQL/"><i class="iconfont icon-githubiconfont icon-tags"></i>NoSQL</a>
                    
                        <a href="/tags/StudyNote/"><i class="iconfont icon-githubiconfont icon-tags"></i>StudyNote</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/posts/16107/">Hello World</a>
            
            
            <a class="next" rel="next" href="/posts/45960/">MySQL基本使用</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Powered by Ityoung</span>
		
			<br/>
			

	<span id="busuanzi_container_site_pv">
		总访问量:
		<span id="busuanzi_value_site_pv"></span>
	</span>


	<span id="busuanzi_container_site_uv">
		总访客量:
		<span  id="busuanzi_value_site_uv"></span>
	</span>&nbsp;

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		
	</div>
	
</footer>

    </div>
</body>
</html>
