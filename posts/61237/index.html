<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ityoung">





<title>排序算法 | 谢谢你这么好看还来访问我的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="谢谢你这么好看还来访问我的博客" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">首页</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/link">友链</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">首页</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/link">友链</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开目录</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">到达尾部</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">排序算法</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Ityoung</a>
                    

                    
                        <span class="post-time">
                        发布时间: <a href="#">2022-04-25&nbsp;&nbsp;09:54:52</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                            
                        </span>
                    
					<br/>
					<!-- 开始添加字数统计-->
					
						

<span class="post-time">
  <span class="post-meta-item-icon">
	<i class="fa fa-keyboard-o"></i>
	<span class="post-meta-item-text">  字数统计: </span>
	<!-- 安装插件npm install hexo-wordcount --save -->
	<span class="post-count" style="color: #2d96bd">5.8k</span>字
  </span>
</span>

<span class="post-time">
  <span class="post-meta-item-icon">
	<i class="fa fa-hourglass-half"></i>
	<span class="post-meta-item-text">  阅读时长: </span>
	<span class="post-count" style="color: #2d96bd">23</span>分
  </span>
</span>

					
					<!-- 添加完成 -->
                </div>
            
			<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> visits</span>
			
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>算法就是编程的灵魂，不会算法的程序员只配做码农。之前看到这句话受到一万点暴击伤害！同时也激起了自己的斗志，坦白说作为一个程序员，我一直知道算法的重要性，但是在算法这一块一直做的不够好，甚至除了大学学过这门课程之后就很少去接触它。因为一开始我就给算法贴上了难，烦，不怎么用的标签，现在想来其实都是在逃避问题。所以决定亡羊补牢，从头开始！</p>
<p>文章首发于个人博客【<a target="_blank" rel="noopener" href="http://www.xiongfrblog.cn/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90-Java%E5%AE%9E%E7%8E%B0.html">http://www.xiongfrblog.cn</a>】</p>
<hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>算法的学习也是有着阶段性的，从入门到简单，再到复杂，再到简单。最后的简单是当你达到一定高度之后对于问题能够准确的找到最简单的解答。就如同修仙一样，真正的高手一招足以击退万马千军！</p>
<p>算法里边最常用也是最基本的就是排序算法和查找算法了，本文主要讲解算法里边最经典的十大排序算法。在这里我们根据他们各自的实现原理以及效率将十大排序算法分为两大类：</p>
<ol>
<li> 非线性比较类排序：非线性是指算法的时间复杂度不能突破 (nlogn)，元素之间通过比较大小来决定先后顺序。</li>
<li> 线性非比较类排序：算法的时间复杂度能够突破 (nlogn)，并且不通过比较来对元素排序。</li>
</ol>
<p>具体分类我们上图说明：</p>
<p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-0ee006290928e248.png"></p>
<p>排序算法分类</p>
<h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><p>这里给出算法的时间复杂度，空间复杂度以及稳定性的对比整理，同样通过图片的形式给出：</p>
<p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-970f536ecc0f3497.png"></p>
<p>算法比较</p>
<p><strong>在这里给出相关指标的解释</strong></p>
<blockquote>
<p><strong>时间复杂度</strong>：时间复杂度本意是预估算法的执行时间，但实际上一个程序在计算机上执行的速度是非常快的，时间几乎可以忽略不计了，也就是失去了意义，所以这里意思是算法中执行频度最高的代码的执行的次数。反应当 n 发生变化时，执行次数的改变呈现一种什么样的规律。<br><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。<br><strong>稳定性</strong>：在排序中对于相等的两个元素 a,b。如果排序前 a 在 b 的前边，排序之后 a 也总是在 b 的前边。他们的位置不会因为排序而改变称之为稳定。反之，如果排序后 a,b 的位置可能会发生改变，那么就称之为不稳定。</p>
</blockquote>
<p>下面就一一对十大算法进行详细的讲解，会给出他们的基本思想，图片演示，以及带有详细注释的源码。（本文所有的排序算法都是升序排序）</p>
<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><hr>
<h3 id="1-1-基本思想"><a href="#1-1-基本思想" class="headerlink" title="1.1 基本思想"></a>1.1 基本思想</h3><p>冒泡排序可以说是最简单的排序之一了，也是大部分人最容易想到的排序。即对 n 个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮， 就可以将最大的数移到数组的最后， 总共循环 n-1 轮，完成对数组排序。</p>
<h3 id="1-2-图片演示"><a href="#1-2-图片演示" class="headerlink" title="1.2 图片演示"></a>1.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-65a6e527966ba60c.gif"></p>
<p>冒泡排序</p>
<h3 id="1-3-代码展示"><a href="#1-3-代码展示" class="headerlink" title="1.3 代码展示"></a>1.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span><br><span class="line">        for(int i=0;i&lt;len-1;i++) &#123;</span><br><span class="line">            //j控制比较次数，第i次循环内需要比较len-i次</span><br><span class="line">            //但是由于是由arr[j]跟arr[j+1]进行比较，所以为了保证arr[j+1]不越界，j&lt;len-i-1</span><br><span class="line">            for(int j=0;j&lt;len-i-1;j++) &#123;</span><br><span class="line">                //如果前一个数比后一个数大，则交换位置将大的数往后放。</span><br><span class="line">                if(arr[j]&gt;arr[j+1]) &#123;</span><br><span class="line">                    int temp=arr[j+1];</span><br><span class="line">                    arr[j+1]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><hr>
<h3 id="2-1-基本思想"><a href="#2-1-基本思想" class="headerlink" title="2.1 基本思想"></a>2.1 基本思想</h3><p>选择排序可以说是冒泡排序的改良版，不再是前一个数跟后一个数相比较， 而是在每一次循环内都由一个数去跟 所有的数都比较一次，每次比较都选取相对较小的那个数来进行下一次的比较，并不断更新较小数的下标 这样在一次循环结束时就能得到最小数的下标，再通过一次交换将最小的数放在最前面，通过 n-1 次循环之后完成排序。 这样相对于冒泡排序来说，比较的次数并没有改变，但是数据交换的次数大大减少。</p>
<h3 id="2-2-图片演示"><a href="#2-2-图片演示" class="headerlink" title="2.2 图片演示"></a>2.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-7dd8394396a15d13.gif"></p>
<p>选择排序</p>
<h3 id="2-3-代码展示"><a href="#2-3-代码展示" class="headerlink" title="2.3 代码展示"></a>2.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span><br><span class="line">        for(int i=0;i&lt;len-1;i++) &#123;</span><br><span class="line">            //minIndex 用来保存每次比较后较小数的下标。</span><br><span class="line">            int minIndex=i;</span><br><span class="line">            //j控制比较次数，因为每次循环结束之后最小的数都已经放在了最前面，</span><br><span class="line">            //所以下一次循环的时候就可以跳过这个数，所以j的初始值为i+1而不需要每次循环都从0开始，并且j&lt;len即可</span><br><span class="line">            for(int j=i+1;j&lt;len;j++) &#123;</span><br><span class="line">                //每比较一次都需要将较小数的下标记录下来</span><br><span class="line">                if(arr[minIndex]&gt;arr[j]) &#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //当完成一次循环时，就需要将本次循环选取的最小数移动到本次循环开始的位置。</span><br><span class="line">            if(minIndex!=i) &#123;</span><br><span class="line">                int temp=arr[i];</span><br><span class="line">                arr[i]=arr[minIndex];</span><br><span class="line">                arr[minIndex]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            //打印每次循环结束之后数组的排序状态（方便理解）</span><br><span class="line">            System.out.println(&quot;第&quot;+(i+1)+&quot;次循环之后效果：&quot;+Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h1><hr>
<h3 id="3-1-基本思想"><a href="#3-1-基本思想" class="headerlink" title="3.1 基本思想"></a>3.1 基本思想</h3><p>插入排序的思想打牌的人肯定很容易理解，就是见缝插针。 首先就默认数组中的第一个数的位置是正确的，即已经排序。 然后取下一个数，与已经排序的数按从后向前的顺序依次比较， 如果该数比当前位置排好序的数小，则将排好序的数的位置向后移一位。 重复上一步骤，直到找到合适的位置。 找到位置后就结束比较的循环，将该数放到相应的位置。</p>
<h3 id="3-2-图片演示"><a href="#3-2-图片演示" class="headerlink" title="3.2 图片演示"></a>3.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-bb6d1e8cbeeda277.gif"></p>
<p>插入排序</p>
<h3 id="3-3-代码展示"><a href="#3-3-代码展示" class="headerlink" title="3.3 代码展示"></a>3.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //i控制循环次数，因为已经默认第一个数的位置是正确的，所以i的起始值为1，i&lt;len，循环len-1次</span><br><span class="line">        for(int i=1;i&lt;len;i++) &#123;</span><br><span class="line">            int j=i;//变量j用来记录即将要排序的数的位置即目标数的原位置</span><br><span class="line">            int target=arr[j];//target用来记录即将要排序的那个数的值即目标值</span><br><span class="line">            //while循环用来为目标值在已经排好序的数中找到合适的位置，</span><br><span class="line">            //因为是从后向前比较，并且是与j-1位置的数比较，所以j&gt;0</span><br><span class="line">            while(j&gt;0 &amp;&amp; target&lt;arr[j-1]) &#123;</span><br><span class="line">                //当目标数的值比它当前位置的前一个数的值小时，将前一个数的位置向后移一位。</span><br><span class="line">                //并且j--使得目标数继续与下一个元素比较</span><br><span class="line">                arr[j]=arr[j-1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            //更目标数的位置。</span><br><span class="line">            arr[j]=target;</span><br><span class="line">            //打印每次循环结束之后数组的排序状态（方便理解）</span><br><span class="line">            System.out.println(&quot;第&quot;+(i)+&quot;次循环之后效果：&quot;+Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h1><hr>
<h3 id="4-1-基本思想"><a href="#4-1-基本思想" class="headerlink" title="4.1 基本思想"></a>4.1 基本思想</h3><p>希尔排序也称为 “缩小增量排序”，原理是先将需要排的数组分成多个子序列，这样每个子序列的元素个数就很少，再分别对每个对子序列进行插入排序。在该数组基本有序后 再进行一次直接插入排序就能完成对整个数组的排序。所以，要采用跳跃分割的策略。这里引入 “增量” 的概念，将相距某个增量的记录两两组合成一个子序列，然后对每个子序列进行直接插入排序， 这样得到的结果才会使基本有序（即小的在前边，大的在后边，不大不小的在中间）。希尔排序就是 直接插入排序的升级版。</p>
<h3 id="4-2-图片演示"><a href="#4-2-图片演示" class="headerlink" title="4.2 图片演示"></a>4.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-cf801534a8955fbb.gif"></p>
<p>希尔排序</p>
<h3 id="4-3-代码展示"><a href="#4-3-代码展示" class="headerlink" title="4.3 代码展示"></a>4.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;//数组的长度</span><br><span class="line">        int k=len/2;//初始的增量为数组长度的一半</span><br><span class="line">        //while循环控制按增量的值来划不同分子序列，每完成一次增量就减少为原来的一半</span><br><span class="line">        //增量的最小值为1，即最后一次对整个数组做直接插入排序</span><br><span class="line">        while(k&gt;0) &#123;</span><br><span class="line">            //里边其实就是升级版的直接插入排序了，是对每一个子序列进行直接插入排序，</span><br><span class="line">            //所以直接将直接插入排序中的‘1’变为‘k’就可以了。</span><br><span class="line">            for(int i=k;i&lt;len;i++) &#123;</span><br><span class="line">                int j=i;</span><br><span class="line">                int target=arr[i];</span><br><span class="line">                while(j&gt;=k &amp;&amp; target&lt;arr[j-k]) &#123;</span><br><span class="line">                    arr[j]=arr[j-k];</span><br><span class="line">                    j-=k;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j]=target;</span><br><span class="line">            &#125;</span><br><span class="line">            //不同增量排序后的结果</span><br><span class="line">            System.out.println(&quot;增量为&quot;+k+&quot;排序之后：&quot;+Arrays.toString(arr));</span><br><span class="line">            k/=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h1><hr>
<h3 id="5-1-基本思想"><a href="#5-1-基本思想" class="headerlink" title="5.1 基本思想"></a>5.1 基本思想</h3><p>总体概括就是从上到下递归拆分，然后从下到上逐步合并。</p>
<blockquote>
<p><strong>递归拆分</strong>：先把待排序数组分为左右两个子序列，再分别将左右两个子序列拆分为四个子子序列，以此类推直到最小的子序列元素的个数为两个或者一个为止。</p>
</blockquote>
<blockquote>
<p><strong>逐步合并</strong>（一定要注意是从下到上层级合并，可以理解为递归的层级返回）：将最底层的最左边的一个子序列排序，然后将从左到右第二个子序列进行排序，再将这两个排好序的子序列合并并排序，然后将最底层从左到右第三个子序列进行排序….. 合并完成之后记忆完成了对数组的排序操作</p>
</blockquote>
<h3 id="5-2-图片演示"><a href="#5-2-图片演示" class="headerlink" title="5.2 图片演示"></a>5.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-f3ab9e9963e1f806.gif"></p>
<p>归并排序</p>
<h3 id="5-3-代码展示"><a href="#5-3-代码展示" class="headerlink" title="5.3 代码展示"></a>5.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;3,8,6,2,1,8&#125;;</span><br><span class="line">        mergeSort(arr,0,arr.length-1);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 递归拆分</span><br><span class="line">     * @param arr 待拆分数组</span><br><span class="line">     * @param left 待拆分数组最小下标</span><br><span class="line">     * @param right 待拆分数组最大下标</span><br><span class="line">     */</span><br><span class="line">    public static void mergeSort(int[] arr,int left,int right) &#123;</span><br><span class="line">        int mid=(left+right)/2; //中间下标</span><br><span class="line">        if(left&lt;right) &#123;</span><br><span class="line">            mergeSort(arr,left,mid);//递归拆分左边</span><br><span class="line">            mergeSort(arr,mid+1,right);//递归拆分右边</span><br><span class="line">            sort(arr,left,mid,right);//合并左右</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 合并两个有序子序列</span><br><span class="line">     * @param arr 待合并数组</span><br><span class="line">     * @param left 待合并数组最小下标</span><br><span class="line">     * @param mid 待合并数组中间下标</span><br><span class="line">     * @param right 待合并数组最大下标</span><br><span class="line">     */</span><br><span class="line">    public static void sort(int[] arr,int left,int mid,int right) &#123;</span><br><span class="line">        int[] temp=new int[right-left+1]; //临时数组，用来保存每次合并年之后的结果</span><br><span class="line">        int i=left;</span><br><span class="line">        int j=mid+1;</span><br><span class="line">        int k=0;//临时数组的初始下标</span><br><span class="line">        //这个while循环能够初步筛选出待合并的了两个子序列中的较小数</span><br><span class="line">        while(i&lt;=mid &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">            if(arr[i]&lt;=arr[j]) &#123;</span><br><span class="line">                temp[k++]=arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[k++]=arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将左边序列中剩余的数放入临时数组</span><br><span class="line">        while(i&lt;=mid) &#123;</span><br><span class="line">            temp[k++]=arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        //将右边序列中剩余的数放入临时数组</span><br><span class="line">        while(j&lt;=right) &#123;</span><br><span class="line">            temp[k++]=arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        //将临时数组中的元素位置对应到真真实的数组中</span><br><span class="line">        for(int m=0;m&lt;temp.length;m++) &#123;</span><br><span class="line">            arr[m+left]=temp[m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h1><hr>
<h3 id="6-1-基本思想"><a href="#6-1-基本思想" class="headerlink" title="6.1 基本思想"></a>6.1 基本思想</h3><p>快速排序也采用了分治的策略，这里引入了‘基准数’的概念。</p>
<ol>
<li> 找一个基准数（一般将待排序的数组的第一个数作为基准数）</li>
<li> 对数组进行分区，将小于等于基准数的全部放在左边，大于基准数的全部放在右边。</li>
<li> 重复 1，2 步骤，分别对左右两个子分区进行分区，一直到各分区只有一个数为止。</li>
</ol>
<h3 id="6-2-图片演示"><a href="#6-2-图片演示" class="headerlink" title="6.2 图片演示"></a>6.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-b22e767e16be53c5.gif"></p>
<p>快速排序</p>
<h3 id="6-3-代码展示"><a href="#6-3-代码展示" class="headerlink" title="6.3 代码展示"></a>6.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;72,6,57,88,60,42,83,73,48,85&#125;;</span><br><span class="line">        quickSort(arr,0,9);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 分区过程</span><br><span class="line">     * @param arr 待分区数组</span><br><span class="line">     * @param left 待分区数组最小下标</span><br><span class="line">     * @param right 待分区数组最大下标</span><br><span class="line">     */</span><br><span class="line">    public static void quickSort(int[] arr,int left,int right) &#123;</span><br><span class="line">        if(left&lt;right) &#123;</span><br><span class="line">            int temp=qSort(arr,left,right);</span><br><span class="line">            quickSort(arr,left,temp-1);</span><br><span class="line">            quickSort(arr,temp+1,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 排序过程</span><br><span class="line">     * @param arr 待排序数组</span><br><span class="line">     * @param left 待排序数组最小下标</span><br><span class="line">     * @param right 待排序数组最大下标</span><br><span class="line">     * @return 排好序之后基准数的位置下标，方便下次的分区</span><br><span class="line">     */</span><br><span class="line">    public static int qSort(int[] arr,int left,int right) &#123;</span><br><span class="line">        int temp=arr[left];//定义基准数，默认为数组的第一个元素</span><br><span class="line">        while(left&lt;right) &#123;//循环执行的条件</span><br><span class="line">            //因为默认的基准数是在最左边，所以首先从右边开始比较进入while循环的判断条件</span><br><span class="line">            //如果当前arr[right]比基准数大，则直接将右指针左移一位，当然还要保证left&lt;right</span><br><span class="line">            while(left&lt;right &amp;&amp; arr[right]&gt;temp) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            //跳出循环说明当前的arr[right]比基准数要小，那么直接将当前数移动到基准数所在的位置，并且左指针向右移一位（left++）</span><br><span class="line">            //这时当前数（arr[right]）所在的位置空出，需要从左边找一个比基准数大的数来填充。</span><br><span class="line">            if(left&lt;right) &#123;</span><br><span class="line">                arr[left++]=arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            //下面的步骤是为了在左边找到比基准数大的数填充到right的位置。</span><br><span class="line">            //因为现在需要填充的位置在右边，所以左边的指针移动，如果arr[left]小于或者等于基准数，则直接将左指针右移一位</span><br><span class="line">            while(left&lt;right &amp;&amp; arr[left]&lt;=temp) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            //跳出上一个循环说明当前的arr[left]的值大于基准数，需要将该值填充到右边空出的位置，然后当前位置空出。</span><br><span class="line">            if(left&lt;right) &#123;</span><br><span class="line">                arr[right--]=arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当循环结束说明左指针和右指针已经相遇。并且相遇的位置是一个空出的位置，</span><br><span class="line">        //这时候将基准数填入该位置，并返回该位置的下标，为分区做准备。</span><br><span class="line">        arr[left]=temp;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h1><hr>
<h3 id="7-1-基本思想"><a href="#7-1-基本思想" class="headerlink" title="7.1 基本思想"></a>7.1 基本思想</h3><p>在此之前要先说一下堆的概念，<strong>堆</strong>是一种特殊的完全二叉树，分为大顶堆和小顶堆。</p>
<blockquote>
<p><strong>大顶堆</strong>：每个结点的值都大于它的左右子结点的值，升序排序用大顶堆。</p>
</blockquote>
<blockquote>
<p><strong>小顶堆</strong>：每个结点的值都小于它的左右子结点的值，降序排序用小顶堆。</p>
</blockquote>
<p>所以，需要先将待排序数组构造成大顶堆的格式，这时候该堆的顶结点就是最大的数，将其与堆的最后一个结点的元素交换。再将剩余的树重新调整成堆，再次首节点与尾结点交换，重复执行直到只剩下最后一个结点完成排序。</p>
<h3 id="7-2-图片演示"><a href="#7-2-图片演示" class="headerlink" title="7.2 图片演示"></a>7.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-f5cc7878eb25ce07.gif" alt="堆排序"></p>
<p>堆排序</p>
<h3 id="7-3-代码展示"><a href="#7-3-代码展示" class="headerlink" title="7.3 代码展示"></a>7.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;72,6,57,88,60,42,83,73,48,85&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //初始化大顶堆（从最后一个非叶节点开始，从左到右，由下到上）</span><br><span class="line">        for(int i=len/2-1;i&gt;=0;i--) &#123;</span><br><span class="line">            adjustHeap(arr,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">        //将顶节点和最后一个节点互换位置，再将剩下的堆进行调整</span><br><span class="line">        for(int j=len-1;j&gt;0;j--) &#123;</span><br><span class="line">            swap(arr,0,j);</span><br><span class="line">            adjustHeap(arr,0,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 整理树让其变成堆</span><br><span class="line">     * @param arr 待整理的数组</span><br><span class="line">     * @param i 开始的结点</span><br><span class="line">     * @param j 数组的长度</span><br><span class="line">     */</span><br><span class="line">    public static void adjustHeap(int[] arr,int i,int j) &#123;</span><br><span class="line">        int temp=arr[i];//定义一个变量保存开始的结点</span><br><span class="line">        //k就是该结点的左子结点下标</span><br><span class="line">        for(int k=2*i+1;k&lt;j;k=2*k+1) &#123;</span><br><span class="line">            //比较左右两个子结点的大小，k始终记录两者中较大值的下标</span><br><span class="line">            if(k+1&lt;j &amp;&amp; arr[k]&lt;arr[k+1]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            //经子结点中的较大值和当前的结点比较，比较结果的较大值放在当前结点位置</span><br><span class="line">            if(arr[k]&gt;temp) &#123;</span><br><span class="line">                arr[i]=arr[k];</span><br><span class="line">                i=k;</span><br><span class="line">            &#125;else&#123;//说明已经是大顶堆</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 交换数据</span><br><span class="line">     * @param arr </span><br><span class="line">     * @param num1</span><br><span class="line">     * @param num2</span><br><span class="line">     */</span><br><span class="line">    public static void swap(int[] arr, int num1,int num2) &#123;</span><br><span class="line">        int temp=arr[num1];</span><br><span class="line">        arr[num1]=arr[num2];</span><br><span class="line">        arr[num2]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h1><hr>
<h3 id="8-1-基本思想"><a href="#8-1-基本思想" class="headerlink" title="8.1 基本思想"></a>8.1 基本思想</h3><p>计数排序采用了一种全新的思路，不再是通过比较来排序，而是将待排序数组中的最大值 + 1 作为一个临时数组的长度，然后用临时数组记录待排序数组中每个元素出现的次数。最后再遍历临时数组，因为是升序，所以从前到后遍历，将临时数组中值 &gt; 0 的数的下标循环取出，依次放入待排序数组中，即可完成排序。计数排序的效率很高，但是实在牺牲内存的前提下，并且有着限制，那就是待排序数组的值必须 限制在一个确定的范围。</p>
<h3 id="8-2-图片演示"><a href="#8-2-图片演示" class="headerlink" title="8.2 图片演示"></a>8.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-6f0bedbcf601c63f.gif"></p>
<p>计数排序</p>
<h3 id="8-3-代码展示"><a href="#8-3-代码展示" class="headerlink" title="8.3 代码展示"></a>8.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;72,6,57,88,60,42,83,73,48,85&#125;;</span><br><span class="line">        countSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void countSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //保存待排序数组中的最大值，目的是确定临时数组的长度（必须）</span><br><span class="line">        int maxNum=arr[0];</span><br><span class="line">        //保存待排序数组中的最小值，目的是确定最终遍历临时数组时下标的初始值（非必需，只是这样可以加快速度，减少循环次数）</span><br><span class="line">        int minNum=arr[0];</span><br><span class="line">        //for循环就是为了找到待排序数组的最大值和最小值</span><br><span class="line">        for(int i=1;i&lt;len;i++) &#123;</span><br><span class="line">            maxNum=maxNum&gt;arr[i]?maxNum:arr[i];</span><br><span class="line">            minNum=minNum&lt;arr[i]?minNum:arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个临时数组</span><br><span class="line">        int[] temp=new int[maxNum+1];</span><br><span class="line">        //for循环是为了记录待排序数组中每个元素出现的次数，并将该次数保存到临时数组中</span><br><span class="line">        for(int i=0;i&lt;len;i++) &#123;</span><br><span class="line">            temp[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //k=0用来记录待排序数组的下标</span><br><span class="line">        int k=0;</span><br><span class="line">        //遍历临时数组，重新为待排序数组赋值。</span><br><span class="line">        for(int i=minNum;i&lt;temp.length;i++) &#123;</span><br><span class="line">            while(temp[i]&gt;0) &#123;</span><br><span class="line">                arr[k++]=i;</span><br><span class="line">                temp[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h1><hr>
<h3 id="9-1-基本思想"><a href="#9-1-基本思想" class="headerlink" title="9.1 基本思想"></a>9.1 基本思想</h3><p>桶排序其实就是计数排序的强化版，需要利用一个映射函数首先定义有限个数个桶，然后将待排序数组内的元素按照函数映射的关系分别放入不同的桶里边，现在不同的桶里边的数据已经做了区分，比如 A 桶里的数要么全部大于 B 桶，要么全部小于 B 桶里的数。但是 A，B 桶各自里边的数还是乱序的。所以要借助其他排序方式（快速，插入，归并）分别对每一个元素个数大于一的桶里边的数据进行排序。最后再将桶里边的元素按照顺序依次放入待排序数组中即可。</p>
<h3 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-f793953e248524a0.png"></p>
<p>桶排序</p>
<h3 id="9-3-代码展示"><a href="#9-3-代码展示" class="headerlink" title="9.3 代码展示"></a>9.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;72,6,57,88,60,42,83,73,48,85&#125;;</span><br><span class="line">        bucketSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void bucketSort(int[] arr) &#123;</span><br><span class="line">        if(arr==null)</span><br><span class="line">            return;</span><br><span class="line">        int len=arr.length;</span><br><span class="line">        //定义桶的个数，这里k的值要视情况而定，这里我们假设待排序数组里的数都是[0,100)之间的。</span><br><span class="line">        int k=10;</span><br><span class="line">        //用嵌套集合来模拟桶，外层集合表示桶，内层集合表示桶里边装的元素。</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; bucket=new ArrayList&lt;&gt;();</span><br><span class="line">        //for循环初始化外层集合即初始化桶</span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            bucket.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        //循环是为了将待排序数组中的元素通过映射函数分别放入不同的桶里边</span><br><span class="line">        for(int i=0;i&lt;len;i++) &#123;</span><br><span class="line">            bucket.get(mapping(arr[i])).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //这个循环是为了将所有的元素个数大于1的桶里边的数据进行排序。</span><br><span class="line">        for(int i=0;i&lt;k;i++) &#123;</span><br><span class="line">            if(bucket.size()&gt;1) &#123;</span><br><span class="line">                //因为这里是用集合来模拟的桶所以用java写好的对集合排序的方法。</span><br><span class="line">                //其实应该自己写一个方法来排序的。</span><br><span class="line">                Collections.sort(bucket.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        //将排好序的数重新放入待排序数组中</span><br><span class="line">        int m=0;</span><br><span class="line">        for(List&lt;Integer&gt; list:bucket) &#123;</span><br><span class="line">            if(list.size()&gt;0) &#123;</span><br><span class="line">                for(Integer a:list) &#123;</span><br><span class="line">                    arr[m++]=a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 映射函数</span><br><span class="line">     * @param num</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static int mapping(int num) &#123;</span><br><span class="line">        return num/10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h1><hr>
<h3 id="10-1-基本思想"><a href="#10-1-基本思想" class="headerlink" title="10.1 基本思想"></a>10.1 基本思想</h3><p>就是将待排序数据拆分成多个<strong>关键字</strong>进行排序，也就是说，基数排序的实质是多关键字排序。多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字； 第 1 个排序关键字，第 2 个排序关键字，第 3 个排序关键字…… 然后，根据子关键字对待排序数据进行排序。</p>
<h3 id="10-2-图片演示"><a href="#10-2-图片演示" class="headerlink" title="10.2 图片演示"></a>10.2 图片演示</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/uPic/15923110-372e37ae9d65a577.gif"></p>
<p>基数排序</p>
<h3 id="10-3-代码展示"><a href="#10-3-代码展示" class="headerlink" title="10.3 代码展示"></a>10.3 代码展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] arr= &#123;720,6,57,88,60,42,83,73,48,85&#125;;</span><br><span class="line">        redixSort(arr,10,3);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void redixSort(int[] arr, int radix, int d) &#123;  </span><br><span class="line">        // 缓存数组  </span><br><span class="line">        int[] tmp = new int[arr.length];  </span><br><span class="line">        // buckets用于记录待排序元素的信息  </span><br><span class="line">        // buckets数组定义了max-min个桶  </span><br><span class="line">        int[] buckets = new int[radix];  </span><br><span class="line">  </span><br><span class="line">        for (int i = 0, rate = 1; i &lt; d; i++) &#123;  </span><br><span class="line">  </span><br><span class="line">            // 重置count数组，开始统计下一个关键字  </span><br><span class="line">            Arrays.fill(buckets, 0);  </span><br><span class="line">            // 将data中的元素完全复制到tmp数组中  </span><br><span class="line">            System.arraycopy(arr, 0, tmp, 0, arr.length);  </span><br><span class="line">  </span><br><span class="line">            // 计算每个待排序数据的子关键字  </span><br><span class="line">            for (int j = 0; j &lt; arr.length; j++) &#123;  </span><br><span class="line">                int subKey = (tmp[j] / rate) % radix;  </span><br><span class="line">                buckets[subKey]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            for (int j = 1; j &lt; radix; j++) &#123;  </span><br><span class="line">                buckets[j] = buckets[j] + buckets[j - 1];  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            // 按子关键字对指定的数据进行排序  </span><br><span class="line">            for (int m = arr.length - 1; m &gt;= 0; m--) &#123;  </span><br><span class="line">                int subKey = (tmp[m] / rate) % radix;  </span><br><span class="line">                arr[--buckets[subKey]] = tmp[m];  </span><br><span class="line">            &#125;  </span><br><span class="line">            rate *= radix;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>作者:</span>
                        <span>Ityoung</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>本站链接:</span>
                        <span><a href="http://www.ityoung.xyz/posts/61237/">http://www.ityoung.xyz/posts/61237/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>执照:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
				<!--
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                
				-->
            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%8E%92%E5%BA%8F/"><i class="iconfont icon-githubiconfont icon-tags"></i>排序</a>
                    
                        <a href="/tags/%E7%AE%97%E6%B3%95/"><i class="iconfont icon-githubiconfont icon-tags"></i>算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/posts/64600/">lambda表达式的使用</a>
            
            
            <a class="next" rel="next" href="/posts/58844/">使用 Stream API 流的方式优化 Java 代码！</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Powered by Ityoung</span>
		
			<br/>
			

	<span id="busuanzi_container_site_pv">
		总访问量:
		<span id="busuanzi_value_site_pv"></span>
	</span>


	<span id="busuanzi_container_site_uv">
		总访客量:
		<span  id="busuanzi_value_site_uv"></span>
	</span>&nbsp;

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		
	</div>
	
</footer>

    </div>
</body>
</html>
