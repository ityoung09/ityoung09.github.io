<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢谢你这么好看还来访问我的博客</title>
  
  
  <link href="http://www.ityoung.xyz/atom.xml" rel="self"/>
  
  <link href="http://www.ityoung.xyz/"/>
  <updated>2021-11-16T04:55:39.193Z</updated>
  <id>http://www.ityoung.xyz/</id>
  
  <author>
    <name>Ityoung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Stream API 流的方式优化 Java 代码！</title>
    <link href="http://www.ityoung.xyz/posts/58844/"/>
    <id>http://www.ityoung.xyz/posts/58844/</id>
    <published>2021-11-16T04:35:08.000Z</published>
    <updated>2021-11-16T04:55:39.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Stream-API-流的方式优化-Java-代码！"><a href="#使用-Stream-API-流的方式优化-Java-代码！" class="headerlink" title="使用 Stream API 流的方式优化 Java 代码！"></a>使用 Stream API 流的方式优化 Java 代码！</h1><p>Java8的新特性主要是Lambda表达式和流，当流和Lambda表达式结合起来一起使用时，因为流申明式处理数据集合的特点，可以让代码变得简洁易读</p><h2 id="放大招，流如何简化代码"><a href="#放大招，流如何简化代码" class="headerlink" title="放大招，流如何简化代码"></a><strong>放大招，流如何简化代码</strong></h2><p>如果有一个需求，需要对数据库查询到的菜肴进行一个处理：</p><ul><li>筛选出卡路里小于400的菜肴</li><li>对筛选出的菜肴进行一个排序</li><li>获取排序后菜肴的名字</li></ul><p>菜肴：Dish.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java8以前的实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">beforeJava7</span> <span class="params">(List &lt;Dish&gt; dishList)</span> </span>&#123;</span><br><span class="line">    List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//1.筛选出卡路里小于400的菜肴</span></span><br><span class="line">    <span class="keyword">for</span> (Dish dish : dishList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dish.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">            lowCaloricDishes.add(dish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.对筛选出的菜肴进行排序</span></span><br><span class="line">    Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish o1, Dish o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1.getCalories(), o2.getCalories());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3.获取排序后菜肴的名字</span></span><br><span class="line">    List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Dish d : lowCaloricDishes) &#123;</span><br><span class="line">        lowCaloricDishesName.add(d.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lowCaloricDishesName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java8之后的实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">afterJava8</span> <span class="params">(List &lt; Dish &gt; dishList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dishList.stream()</span><br><span class="line">            .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)</span><br><span class="line">            .sorted(comparing(Dish::getCalories))</span><br><span class="line">            .map(Dish::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不拖泥带水，一气呵成，原来需要写24代码实现的功能现在只需5行就可以完成了</p><p>高高兴兴写完需求这时候又有新需求了，新需求如下：</p><blockquote><p>对数据库查询到的菜肴根据菜肴种类进行分类，返回一个Map&lt;Type,List<Dish>&gt;的结果</p></blockquote><p>这要是放在jdk8之前肯定会头皮发麻</p><p><strong>Java8以前的实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Type, List&lt;Dish&gt;&gt; beforeJdk8 (List &lt; Dish &gt; dishList) &#123;</span><br><span class="line">    Map&lt;Type, List&lt;Dish&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Dish dish : dishList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.get(dish.getType()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Dish&gt; dishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            dishes.add(dish);</span><br><span class="line">            result.put(dish.getType(), dishes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.get(dish.getType()).add(dish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还好jdk8有Stream，再也不用担心复杂集合处理需求</p><p><strong>Java8以后的实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Type, List&lt;Dish&gt;&gt; afterJdk8 (List &lt; Dish &gt; dishList) &#123;</span><br><span class="line">    <span class="keyword">return</span> dishList.stream().collect(groupingBy(Dish::getType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一行代码解决了需求，忍不住大喊Stream API牛批 看到流的强大功能了吧，接下来将详细介绍流</p><h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a><strong>什么是流</strong></h2><p>流是从支持数据处理操作的源生成的元素序列，源可以是数组、文件、集合、函数。流不是集合元素，它不是数据结构并不保存数据，它的主要目的在于计算</p><h2 id="如何生成流"><a href="#如何生成流" class="headerlink" title="如何生成流"></a><strong>如何生成流</strong></h2><p>生成流的方式主要有五种</p><p><strong>1、通过集合生成，应用中最常用的一种</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream();</span><br></pre></td></tr></table></figure><p>通过集合的stream方法生成流</p><p><strong>2、通过数组生成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream stream = Arrays.stream(intArr);</span><br></pre></td></tr></table></figure><p>通过Arrays.stream方法生成流，并且该方法生成的流是数值流【即IntStream】而不是 <code>Stream&lt;Integer&gt;</code>。补充一点使用数值流可以避免计算过程中拆箱装箱，提高性能。</p><p>Stream API提供了mapToInt、mapToDouble、mapToLong三种方式将对象流【即Stream 】转换成对应的数值流，同时提供了boxed方法将数值流转换为对象流</p><p><strong>3、通过值生成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>通过Stream的of方法生成流，通过Stream的empty方法可以生成一个空流</p><p><strong>4、通过文件生成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset())</span><br></pre></td></tr></table></figure><p>通过Files.line方法得到一个流，并且得到的每个流是给定文件中的一行</p><p><strong>5、通过函数生成 提供了iterate和generate两个静态方法从函数中生成流</strong></p><p>iterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>iterate方法接受两个参数，第一个为初始化值，第二个为进行的函数操作，因为iterator生成的流为无限流，通过limit方法对流进行了截断，只生成5个偶数</p><p>generator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>generate方法接受一个参数，方法参数类型为Supplier ，由它为流提供值。generate生成的流也是无限流，因此通过limit对流进行了截断</p><h2 id="流的操作类型"><a href="#流的操作类型" class="headerlink" title="流的操作类型"></a><strong>流的操作类型</strong></h2><p>流的操作类型主要分为两种</p><p><strong>1、中间操作</strong></p><p>一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，仅仅调用到这类方法，并没有真正开始流的遍历，真正的遍历需等到终端操作时，常见的中间操作有下面即将介绍的filter、map等</p><p><strong>2、终端操作</strong></p><p>一个流有且只能有一个终端操作，当这个操作执行后，流就被关闭了，无法再被操作，因此一个流只能被遍历一次，若想在遍历需要通过源数据在生成流。终端操作的执行，才会真正开始流的遍历。如下面即将介绍的count、collect等</p><h2 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a><strong>流使用</strong></h2><p>流的使用将分为终端操作和中间操作进行介绍</p><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a><strong>中间操作</strong></h3><p><strong>filter筛选</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>通过使用filter方法进行条件筛选，filter的方法参数为一个条件</p><p><strong>distinct去除重复元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Stream&lt;Integer&gt; stream = integerList.stream().distinct();</span><br></pre></td></tr></table></figure><p>通过distinct方法快速去除重复的元素</p><p><strong>limit返回指定流个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  Stream&lt;Integer&gt; stream = integerList.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>通过limit方法指定返回流的个数，limit的参数值必须&gt;=0，否则将会抛出异常</p><p><strong>skip跳过流中的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  Stream&lt;Integer&gt; stream = integerList.stream().skip(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>通过skip方法跳过流中的元素，上述例子跳过前两个元素，所以打印结果为2,3,4,5，skip的参数值必须&gt;=0，否则将会抛出异常</p><p><strong>map流映射</strong></p><p>所谓流映射就是将接受的元素映射成另外一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;Java 8&quot;</span>, <span class="string">&quot;Lambdas&quot;</span>,  <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);Stream&lt;Integer&gt; stream = stringList.stream().map(String::length);</span><br></pre></td></tr></table></figure><p>通过map方法可以完成映射，该例子完成中String -&gt; Integer的映射，之前上面的例子通过map方法完成了Dish-&gt;String的映射</p><p><strong>flatMap流转换</strong></p><p>将一个流中的每个值都转换为另一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; wordList = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);List&lt;String&gt; strList = wordList.stream().map(w -&gt; w.split(<span class="string">&quot; &quot;</span>)).flatMap(Arrays::stream)        .distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>map(w -&gt; w.split(“ “))的返回值为 <code>Stream&lt;String[]&gt;</code>，我们想获取 <code>Stream&lt;String&gt;</code>，可以通过flatMap方法完成Stream -&gt;Stream 的转换</p><p><strong>元素匹配</strong></p><p>提供了三种匹配方式</p><p><strong>1、allMatch匹配所有</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="keyword">if</span> (integerList.stream().allMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;      System.out.println(<span class="string">&quot;值都大于3&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>通过allMatch方法实现</p><p><strong>2、anyMatch匹配其中一个</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="keyword">if</span> (integerList.stream().anyMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;      System.out.println(<span class="string">&quot;存在大于3的值&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer i : integerList) &#123;      <span class="keyword">if</span> (i &gt; <span class="number">3</span>) &#123;            System.out.println(<span class="string">&quot;存在大于3的值&quot;</span>);           <span class="keyword">break</span>;      &#125;&#125;</span><br></pre></td></tr></table></figure><p>存在大于3的值则打印，java8中通过anyMatch方法实现这个功能</p><p><strong>3、noneMatch全部不匹配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="keyword">if</span> (integerList.stream().noneMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;      System.out.println(<span class="string">&quot;值都小于3&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>通过noneMatch方法实现</p><h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a><strong>终端操作</strong></h2><p><strong>统计流中元素个数</strong></p><p><strong>1、通过count</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Long result = integerList.stream().count();</span><br></pre></td></tr></table></figure><p>通过使用count方法统计出流中元素个数</p><p><strong>2、通过counting</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Long result = integerList.stream().collect(counting());</span><br></pre></td></tr></table></figure><p>最后一种统计元素个数的方法在与collect联合使用的时候特别有用</p><p><strong>查找</strong></p><p>提供了两种查找方式</p><p><strong>1、findFirst查找第一个</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findFirst();</span><br></pre></td></tr></table></figure><p>通过findFirst方法查找到第一个大于三的元素并打印</p><p><strong>2、findAny随机查找一个</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findAny();</span><br></pre></td></tr></table></figure><p>通过findAny方法查找到其中一个大于三的元素并打印，因为内部进行优化的原因，当找到第一个满足大于三的元素时就结束，该方法结果和findFirst方法结果一样。提供findAny方法是为了更好的利用并行流，findFirst方法在并行上限制更多【本篇文章将不介绍并行流】</p><p><strong>reduce将流中的元素组合起来</strong></p><p>假设我们对一个集合中的值进行求和</p><p>jdk8之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i : integerList) &#123;  sum += i;&#125;</span><br></pre></td></tr></table></figure><p>jdk8之后通过reduce进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = integerList.stream().reduce(<span class="number">0</span>, (a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure><p>一行就可以完成，还可以使用方法引用简写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = integerList.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>reduce接受两个参数，一个初始值这里是0，一个 <code>BinaryOperator&lt;T&gt;accumulator</code><br>来将两个元素结合起来产生一个新值，</p><p>另外reduce方法还有一个没有初始化值的重载方法</p><p><strong>获取流中最小最大值</strong></p><p><strong>通过min/max获取最小最大值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).min(Integer::compareTo);Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).max(Integer::compareTo);</span><br></pre></td></tr></table></figure><p>也可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt min = menu.stream().mapToInt(Dish::getCalories).min();OptionalInt max = menu.stream().mapToInt(Dish::getCalories).max();</span><br></pre></td></tr></table></figure><p>min获取流中最小值，max获取流中最大值，方法参数为 <code>Comparator&lt;?superT&gt;comparator</code></p><p><strong>通过minBy/maxBy获取最小最大值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).collect(minBy(Integer::compareTo));Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).collect(maxBy(Integer::compareTo));</span><br></pre></td></tr></table></figure><p>minBy获取流中最小值，maxBy获取流中最大值，方法参数为 <code>Comparator&lt;?superT&gt;comparator</code></p><p><strong>通过reduce获取最小最大值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).reduce(Integer::min);Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).reduce(Integer::max);</span><br></pre></td></tr></table></figure><p><strong>求和</strong></p><p><strong>通过summingInt</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().collect(summingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure><p>如果数据类型为double、long，则通过summingDouble、summingLong方法进行求和</p><p><strong>通过reduce</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().map(Dish::getCalories).reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p><strong>通过sum</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().mapToInt(Dish::getCalories).sum();</span><br></pre></td></tr></table></figure><p>在上面求和、求最大值、最小值的时候，对于相同操作有不同的方法可以选择执行。可以选择collect、reduce、min/max/sum方法，推荐使用min、max、sum方法。因为它最简洁易读，同时通过mapToInt将对象流转换为数值流，避免了装箱和拆箱操作</p><p><strong>通过averagingInt求平均值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = menu.stream().collect(averagingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure><p>如果数据类型为double、long，则通过averagingDouble、averagingLong方法进行求平均</p><p><strong>通过summarizingInt同时求总和、平均值、最大值、最小值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics intSummaryStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));<span class="keyword">double</span> average = intSummaryStatistics.getAverage();  <span class="comment">//获取平均值int min = intSummaryStatistics.getMin();  //获取最小值int max = intSummaryStatistics.getMax();  //获取最大值long sum = intSummaryStatistics.getSum();  //获取总和</span></span><br></pre></td></tr></table></figure><p>如果数据类型为double、long，则通过summarizingDouble、summarizingLong方法</p><p><strong>通过foreach进行元素遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);integerList.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>而在jdk8之前实现遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : integerList) &#123;      System.out.println(i);&#125;</span><br></pre></td></tr></table></figure><p>jdk8之后遍历元素来的更为方便，原来的for-each直接通过foreach方法就能实现了</p><p><strong>返回集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = menu.stream().map(Dish::getName).collect(toList());Set&lt;String&gt; sets = menu.stream().map(Dish::getName).collect(toSet());</span><br></pre></td></tr></table></figure><p>只举例了一部分，还有很多其他方法 jdk8之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();    Set&lt;String&gt; stringSet = <span class="keyword">new</span> HashSet&lt;&gt;();    <span class="keyword">for</span> (Dish dish : menu) &#123;          stringList.add(dish.getName());          stringSet.add(dish.getName());&#125;</span><br></pre></td></tr></table></figure><p>通过遍历和返回集合的使用发现流只是把原来的外部迭代放到了内部进行，这也是流的主要特点之一。内部迭代可以减少好多代码量</p><p><strong>通过joining拼接流中的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = menu.stream().map(Dish::getName).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br></pre></td></tr></table></figure><p>默认如果不通过map方法进行映射处理拼接的toString方法返回的字符串，joining的方法参数为元素的分界符，如果不指定生成的字符串将是一串的，可读性不强</p><p><strong>进阶通过groupingBy进行分组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Type, List&lt;Dish&gt;&gt; result = dishList.stream().collect(groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure><p>在collect方法中传入groupingBy进行分组，其中groupingBy的方法参数为分类函数。还可以通过嵌套使用groupingBy进行多级分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Type, List&lt;Dish&gt;&gt; result = menu.stream().collect(groupingBy(Dish::getType, groupingBy(dish -&gt; &#123;    <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;&#125;)));</span><br></pre></td></tr></table></figure><p><strong>进阶通过partitioningBy进行分区</strong></p><p>分区是特殊的分组，它分类依据是true和false，所以返回的结果最多可以分为两组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(partitioningBy(Dish :: isVegetarian))</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(groupingBy(Dish :: isVegetarian))</span><br></pre></td></tr></table></figure><p>这个例子可能并不能看出分区和分类的区别，甚至觉得分区根本没有必要，换个明显一点的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Map&lt;Boolean, List&lt;Integer&gt;&gt; result = integerList.stream().collect(partitioningBy(i -&gt; i &lt; <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>返回值的键仍然是布尔类型，但是它的分类是根据范围进行分类的，分区比较适合处理根据范围进行分类</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过使用Stream API可以简化代码，同时提高了代码可读性，赶紧在项目里用起来。讲道理在没学Stream API之前，谁要是给我在应用里写很多Lambda，Stream API，飞起就想给他一脚。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-Stream-API-流的方式优化-Java-代码！&quot;&gt;&lt;a href=&quot;#使用-Stream-API-流的方式优化-Java-代码！&quot; class=&quot;headerlink&quot; title=&quot;使用 Stream API 流的方式优化 Java 代码！&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://www.ityoung.xyz/categories/Java/"/>
    
    
    <category term="Java高级" scheme="http://www.ityoung.xyz/tags/Java%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus常用配置</title>
    <link href="http://www.ityoung.xyz/posts/30588/"/>
    <id>http://www.ityoung.xyz/posts/30588/</id>
    <published>2021-09-18T02:12:16.000Z</published>
    <updated>2021-11-16T05:09:45.776Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker进阶篇</title>
    <link href="http://www.ityoung.xyz/posts/31189/"/>
    <id>http://www.ityoung.xyz/posts/31189/</id>
    <published>2021-09-18T02:11:48.000Z</published>
    <updated>2021-09-23T02:02:13.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频链接：<a href="https://www.bilibili.com/video/BV1og4y1q7M4%EF%BC%88%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84B%E7%AB%99%E7%8B%82%E7%A5%9E%E8%AF%B4%EF%BC%89">https://www.bilibili.com/video/BV1og4y1q7M4（大名鼎鼎的B站狂神说）</a></p><p>原文链接：<a href="https://blog.csdn.net/Mr_YanMingXin/article/details/119597321">https://blog.csdn.net/Mr_YanMingXin/article/details/119597321</a></p></blockquote><h3 id="1-Docker镜像详解"><a href="#1-Docker镜像详解" class="headerlink" title="1 Docker镜像详解"></a>1 Docker镜像详解</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923100107326.png" alt="image-20210923100107326"></p><p>1.1 UnionFS（联合文件系统）</p><ul><li>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</li><li>特性：一次同时加载多个文件系统，但从外面看起来只能看到一个文件系统。联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul><h4 id="1-2-镜像加载原理"><a href="#1-2-镜像加载原理" class="headerlink" title="1.2 镜像加载原理"></a>1.2 镜像加载原理</h4><p>Docker的镜像实际由一层一层的文件系统组成：</p><ul><li>bootfs（boot file system）主要包含bootloader和kernel。bootloader主要是引导加载kernel，完成后整个内核就都在内存中了。此时内存的使用权已由bootfs转交给内核，系统卸载bootfs。可以被不同的Linux发行版公用。</li><li>rootfs（root file system），包含典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同操作系统发行版（Ubuntu，Centos等）。因为底层直接用Host的kernel，rootfs只包含最基本的命令，工具和程序就可以了。</li><li>分层理解<br><code>所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的容器层</code>。<br>容器在启动时会在镜像最外层上建立一层可读写的容器层（R/W），而镜像层是只读的（R/O）。</li></ul><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918112504261.png" alt="image-20210918112504261"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;描述信息&quot; -a &quot;作者&quot; 容器ID  目标镜像名:[tag]  # 编辑容器后提交容器成为一个新镜像</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat                latest    46cfbf1293b1   13 days ago    668MB</span><br><span class="line">.....</span><br><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker commit --help</span><br><span class="line"></span><br><span class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">Create a new image from a container&#x27;s changes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --author string    Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span><br><span class="line">  -c, --change list      Apply Dockerfile instruction to the created image</span><br><span class="line">  -m, --message string   Commit message</span><br><span class="line">  -p, --pause            Pause container during commit (default true)</span><br><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker commit -m &quot;Ymx tomcat&quot; -a &quot;ymx&quot; 46cfbf1293b1 ymxtomcat:1.0</span><br><span class="line">Error response from daemon: No such container: 46cfbf1293b1</span><br><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker commit -m &quot;Ymx tomcat&quot; -a &quot;ymx&quot; tomcat  ymxtomcat:1.0</span><br><span class="line">sha256:ee3100b86b4939d52415da7a62c91d987d91be3ea4776f0ae3d2024b94fed6b4</span><br><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ymxtomcat             1.0       ee3100b86b49   5 seconds ago   668MB</span><br><span class="line">tomcat                latest    46cfbf1293b1   13 days ago     668MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="2-容器数据卷"><a href="#2-容器数据卷" class="headerlink" title="2 容器数据卷"></a>2 容器数据卷</h3><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918112606471.png" alt="image-20210918112606471"></p><h4 id="2-1-什么是容器数据卷？"><a href="#2-1-什么是容器数据卷？" class="headerlink" title="2.1 什么是容器数据卷？"></a>2.1 什么是容器数据卷？</h4><p><code>为了实现数据持久化，使容器之间可以共享数据。可以将容器内的目录，挂载到宿主机上或其他容器内，实现同步和共享的操作。即使将容器删除，挂载到本地的数据卷也不会丢失。</code></p><h4 id="2-2-指定路径挂载"><a href="#2-2-指定路径挂载" class="headerlink" title="2.2 指定路径挂载"></a>2.2 指定路径挂载</h4><h5 id="2-2-1-直接使用命令"><a href="#2-2-1-直接使用命令" class="headerlink" title="2.2.1 直接使用命令"></a>2.2.1 直接使用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机内目录:容器内目录 镜像名/id</span><br></pre></td></tr></table></figure><p>将容器内目录挂载到主机内目录上，通过**docker inspect [容器名或ID]**命令查看该容器即可以看到挂载信息：<br><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210917172856343.png" alt="image-20210917172856343"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载命令</span></span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker run -it -v /opt/Docker/20210806/:/opt centos /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入到容器内部</span></span><br><span class="line">[root@e749444d0ee1 /]# cd opt/</span><br><span class="line">[root@e749444d0ee1 opt]# ls -l </span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Aug  6 03:35 ymx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本机</span></span><br><span class="line">[root@iZ1608aqb7ntn9Z ~]# cd /opt/Docker/20210806/</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 8月   6 11:35 ymx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker inspect [容器名或ID] 查看挂载</span></span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker inspect e749444d0ee1 </span><br><span class="line">......</span><br><span class="line">     &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/opt/Docker/20210806&quot;,  # 对应主机的源目录</span><br><span class="line">                &quot;Destination&quot;: &quot;/opt&quot;,    # 容器中的目录</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>建立挂载关系后，只要使用命令在主机内新建一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /home/mountdir/test.txt</span><br></pre></td></tr></table></figure><p>就会在容器内的挂载目录下发现相同的文件（test.txt），从而实现了容器和主机的文件同步和共享。 </p><h5 id="2-2-2实战安装MySQL"><a href="#2-2-2实战安装MySQL" class="headerlink" title="2.2.2实战安装MySQL"></a>2.2.2实战安装MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.搜索MySQL镜像</span></span><br><span class="line">[root@localhost /]# docekr search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">2.下载MySQL镜像</span></span><br><span class="line">[root@localhost /]# docker pull mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">ps:这里我们需要注意的是mysql是需要密码的(去官方看看测试实例)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3.启动镜像并使用容器数据卷</span></span><br><span class="line">[root@localhost /]# docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>成功之后Linux本地上就会有这些文件,<code>即使当容器删除了,本地的这些文件内容也不会消失。容器数据持久化</code></p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918114737612.png" alt="image-20210918114737612"></p><h4 id="2-3-匿名挂载"><a href="#2-3-匿名挂载" class="headerlink" title="2.3 匿名挂载"></a>2.3 匿名挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v 容器内目录  镜像名/id  # 匿名挂载</span><br></pre></td></tr></table></figure><p>匿名挂载后，使用 <strong>docker volume ls</strong>命令查看所有挂载的卷：</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918141219586.png" alt="image-20210918141219586"></p><p>每一个VOLUME NAME对应一个挂载的卷，由于挂载时未指定主机目录，因此无法直接找到目录。</p><h4 id="2-4-具名挂载"><a href="#2-4-具名挂载" class="headerlink" title="2.4 具名挂载"></a>2.4 具名挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v 卷名:容器内目录  镜像名/id</span><br><span class="line"><span class="comment">#测试示例,-P是随机分配一个端口</span></span><br><span class="line">docker run -d -P --name nginx01 -v volume01:/etc/nginx nginx</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918141657797.png" alt="image-20210918141657797"></p><p>可以发现挂载的卷：volume01，并通过 <strong>docker volume inspect 卷名</strong> 命令找到主机内目录：</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918141747138.png" alt="image-20210918141747138"></p><p>所有docker容器内的卷，在未指定主机内目录时，都在：<code> _/var/lib/docker/volumes/卷名/_data_ 下</code>，可通过具名挂载可以方便的找到卷，因此广泛使用这种方式进行挂载。</p><p><strong>拓展</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过 -v 容器内路径:ro rw 改变读写权限</span></span><br><span class="line">ro readonly #只读</span><br><span class="line">rw readwrite #读写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一旦这个设置了容器权限,容器对我们挂载出来的内容就有了限定了!</span></span><br><span class="line">docker run -d -P --name nginx01 -v volume01:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx01 -v volume01:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ro 只要看到这个ro说明这个路径只能通过宿主机来进行操作, 容器内部可以改变!</span></span><br></pre></td></tr></table></figure><h4 id="2-5-数据卷容器"><a href="#2-5-数据卷容器" class="headerlink" title="2.5 数据卷容器"></a>2.5 数据卷容器</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918145033256.png" alt="image-20210918145033256"></p><p>😊示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name container02 --volumes from container01 镜像名/id  <span class="comment"># 将两个容器进行挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02   --volumes-from mysql01 mysql:5.7</span></span><br></pre></td></tr></table></figure><h3 id="3-DockerFile"><a href="#3-DockerFile" class="headerlink" title="3 DockerFile"></a>3 DockerFile</h3><p>Dockerfile是用来构建docker镜像的文件</p><h4 id="3-1-构建步骤："><a href="#3-1-构建步骤：" class="headerlink" title="3.1 构建步骤："></a>3.1 构建步骤：</h4><p>编写一个dockerfile文件,随后运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名为Dockerfile时可省略且最后的.不要忽略</span></span><br><span class="line">docker build -f 文件路径 -t 镜像名 .  </span><br><span class="line">docker run     <span class="comment"># 运行镜像</span></span><br><span class="line">docker push    <span class="comment"># 发布镜像</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# vim Dockerfile </span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------写入内容-----------------</span></span><br><span class="line">FROM centos      # 来自centos</span><br><span class="line">CMD /bin/bash    # 进入到/bin/bash</span><br><span class="line">CMD echo Hello Dockerfile   # 输出Hello Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------写入结束-----------------</span></span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker build -f ./Dockerfile -t mydocker .</span><br><span class="line">Sending build context to Docker daemon   2.56kB</span><br><span class="line">Step 1/3 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 300e315adb2f</span></span><br><span class="line">Step 2/3 : CMD /bin/bash</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 526f489adf0b</span></span><br><span class="line">Removing intermediate container 526f489adf0b</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 3c2af9c73098</span></span><br><span class="line">Step 3/3 : CMD echo Hello Dockerfile</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 023af54a93e2</span></span><br><span class="line">Removing intermediate container 023af54a93e2</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7753b44c9137</span></span><br><span class="line">Successfully built 7753b44c9137</span><br><span class="line">Successfully tagged mydocker:latest</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">mydocker              latest    7753b44c9137   6 seconds ago    209MB</span><br><span class="line">......</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker run -it mydocker</span><br><span class="line">Hello Dockerfile</span><br></pre></td></tr></table></figure><h4 id="3-2-Dockerfile命令"><a href="#3-2-Dockerfile命令" class="headerlink" title="3.2 Dockerfile命令"></a>3.2 Dockerfile命令</h4><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">基础镜像：Centos/Ubuntu</td></tr><tr><td align="center">MAINTAINER</td><td align="center">镜像作者+邮箱</td></tr><tr><td align="center">RUN</td><td align="center">镜像构建的时候需要运行的命令</td></tr><tr><td align="center">ADD</td><td align="center">为镜像添加内容（压缩包）</td></tr><tr><td align="center">WORKDIR</td><td align="center">镜像工作目录（进入容器时的目录）</td></tr><tr><td align="center">VOLUME</td><td align="center">挂载的目录</td></tr><tr><td align="center">EXPOSE</td><td align="center">暴露端口配置</td></tr><tr><td align="center">CMD/ENTRYPOINT</td><td align="center">指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td></tr><tr><td align="center">COPY</td><td align="center">类似于ADD，将文件拷贝到镜像中</td></tr><tr><td align="center">ENV</td><td align="center">构建时设置环境变量</td></tr></tbody></table><h4 id="3-3-构建过程"><a href="#3-3-构建过程" class="headerlink" title="3.3 构建过程"></a>3.3 构建过程</h4><ol><li>每个保留关键字（指令）都必须是大写字母</li><li>从上到下顺序执行</li><li>“#” 表示注释</li><li>每一个指令都会创建提交一个新的镜像层并提交</li></ol><h4 id="3-4-构建实例-jdk-tomcat"><a href="#3-4-构建实例-jdk-tomcat" class="headerlink" title="3.4 构建实例(jdk+tomcat)"></a>3.4 构建实例(jdk+tomcat)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# vim DockerFile2</span><br><span class="line"><span class="meta">#</span><span class="bash"> -----------写入文件--------------</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">  </span><br><span class="line">COPY ymx /opt/Docker/20210806/ymx</span><br><span class="line"></span><br><span class="line">ADD jdk8.tar.gz /usr/local</span><br><span class="line">ADD tomcat.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_141</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -----------写入文件完成--------------</span></span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# ls</span><br><span class="line">Dockerfile  DockerFile2  ymx</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# cp /tmp/jdk8.tar.gz jdk8.tar.gz</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# cp /tmp/tomcat.tar.gz tomcat.tar.gz</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# ls</span><br><span class="line">Dockerfile  DockerFile2  jdk8.tar.gz  tomcat.tar.gz  ymx</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker build -f ./DockerFile2 -t mytomcat9 . </span><br><span class="line">Sending build context to Docker daemon    197MB</span><br><span class="line">Step 1/11 : FROM centos</span><br><span class="line">......</span><br><span class="line">Successfully built 86a9a8dd939a</span><br><span class="line">Successfully tagged mytomcat9:latest</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">mytomcat9             latest    86a9a8dd939a   26 seconds ago      667MB</span><br><span class="line">......</span><br><span class="line">[root@iZ1608aqb7ntn9Z 20210806]# docker run -it mytomcat9 /bin/bash</span><br><span class="line">[root@ed5fd71834e2 local]# ls</span><br><span class="line">apache-tomcat-9.0.44  bin  etc  games  include  jdk1.8.0_141  lib  lib64  libexec  sbin  share  src</span><br><span class="line">[root@ed5fd71834e2 local]# java -version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210918171625075.png" alt="image-20210918171625075"></p><h3 id="4-Docker网络"><a href="#4-Docker网络" class="headerlink" title="4 Docker网络"></a>4 Docker网络</h3><h4 id="4-1-理解Docker"><a href="#4-1-理解Docker" class="headerlink" title="4.1 理解Docker"></a>4.1 理解Docker</h4><p>通过命令 <strong>ip addr</strong>查看本地ip地址，我们发现除了本机回环地址和埃里远的内网地址外，还多了一个网卡：Docker0，这是Docker服务启动后自动生成的。</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095031300.png" alt="image-20210923095031300"></p><p>而如果进入一个正在后台运行的tomcat容器，同样使用 <strong>ip addr</strong>命令，发现容器得到了一个新的网络： <strong>12: eth@if13</strong>，ip地址： <strong>172.17.0.2</strong>。这是Docker在容器启动时为其分配的。</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923094909167.png" alt="image-20210923094909167"></p><p>思考一个问题：此时我们的linux主机可以ping通容器内部（ <strong>172.17.0.2</strong>）吗？（ <strong>注意与容器暴露端口相区分</strong>）</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923094958986.png" alt="image-20210923094958986"></p><ul><li>linux可以ping通docker容器内部，因为docker0的ip地址为 <strong>172.17.0.1</strong>，容器为 <strong>172.17.0.2</strong>。</li><li>原理：我们每启动一个docker容器，docker就会给容器分配一个默认的可用ip，我们只要安装了docker，就会有一个网卡docker0(bridge)。网卡采用桥接模式，并使用veth-pair技术（veth-pair就是一堆虚拟设备接口，成对出现，一段连着协议，一段彼此相连，充当一个桥梁。）。</li><li>这时我们退出容器，回到主机再次观察主机的ip地址：</li></ul><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095049288.png" alt="image-20210923095049288"></p><ul><li>我们惊奇地发现了一个新网络 <strong>13: vethda1df4b@if12</strong>，对应容器内网络地址的 <strong>12: eth@if13</strong>。</li><li>容器和容器之间是可以互相ping通的：容器1→Docker0→容器2</li></ul><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095106624.png" alt="image-20210923095106624"></p><ul><li>docker中的所有网络接口都是虚拟的 ，转发效率高。删除容器后，对应的网桥也随之删除。</li></ul><h4 id="4-2-–link"><a href="#4-2-–link" class="headerlink" title="4.2 –link"></a>4.2 –link</h4><p>若编写一个微服务并连接数据库，如果数据库ip改变，如何根据容器名而不是ip访问容器？显然，直接使用容器名是无法ping通容器内部的：<img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095127786.png" alt="image-20210923095127786"></p><p>这时我们可以在容器启动命令中加入一个选项： <strong>–link</strong>，使得我们可以根据容器名来访问容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --link 容器名/id 镜像名/id</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095147336.png" alt="image-20210923095147336"></p><p>然而反向就不可以ping通，这是因为–link的本质是把需要连接的容器名/id写入启动容器的配置文件中，即增加了一个ip和容器名/id的映射：</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095156628.png" alt="image-20210923095156628"></p><p>目前已经不建议使用这种方式。</p><h4 id="4-3-自定义网络"><a href="#4-3-自定义网络" class="headerlink" title="4.3 自定义网络"></a>4.3 自定义网络</h4><p>我们使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095230483.png" alt="image-20210923095230483"></p><p>docker中的网络模式有：</p><ul><li>bridge：桥接（docker默认）/</li><li>none：不配置网络 /</li><li>host：和宿主机共享网络</li></ul><p><strong>docker run</strong> 命令默认带有一个参数–net bridge，此处的bridge指的就是docker0。如果我们不想使用docker0，那如何创建一个新的网络呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  network create --driver 网络模式 --subnet 子网ip --gateway 网关 网络名</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095359909.png" alt="image-20210923095359909"></p><p>我们不仅在 <strong>docker network ls</strong>命令下发现了这个新创建的网络newnet，还可以使用 <strong>docker network inspect</strong>命令查看其详细信息，包括了我们创建时定义的子网ip和网关：</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095423054.png" alt="image-20210923095423054"></p><p>只要两个容器启动时都通过 <strong>–net</strong>，选用了同一个已创建的网络，不同容器间即可通过ip地址或容器名/id连通:<br><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095345780.png" alt="image-20210923095345780"></p><h4 id="4-4-网络连通"><a href="#4-4-网络连通" class="headerlink" title="4.4 网络连通"></a>4.4 网络连通</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095335931.png" alt="image-20210923095335931"></p><p>对于建立在不同网络下(docker0, newnet)的两个容器tomcat01和tomcat02，他们的网段不同，因此是无法彼此ping通容器内部的：</p><p>这时我们需要通过 <strong>docker network connect</strong>命令打通容器与网络之间的连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect 网络名 容器名/id</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210923095307924.png" alt="image-20210923095307924"></p><h3 id="5-SpringBoot项目打包Docker镜像"><a href="#5-SpringBoot项目打包Docker镜像" class="headerlink" title="5 SpringBoot项目打包Docker镜像"></a>5 SpringBoot项目打包Docker镜像</h3><p>1、构建SpringBoot项目</p><p>2、打包运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>3、编写Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">COPY *.jar /app.jar</span><br><span class="line">CMD [&quot;--server.port=8080&quot;]</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>4、构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t xxxxx:xx  .</span></span><br></pre></td></tr></table></figure><p>5、发布运行</p><p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1og4y1q7M4%EF%BC%88%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84B%E7%AB%99%E7</summary>
      
    
    
    
    <category term="Docker" scheme="http://www.ityoung.xyz/categories/Docker/"/>
    
    
    <category term="Linux" scheme="http://www.ityoung.xyz/tags/Linux/"/>
    
    <category term="容器" scheme="http://www.ityoung.xyz/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础篇</title>
    <link href="http://www.ityoung.xyz/posts/25375/"/>
    <id>http://www.ityoung.xyz/posts/25375/</id>
    <published>2021-09-18T02:06:17.000Z</published>
    <updated>2021-09-23T01:55:34.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频链接：<a href="https://www.bilibili.com/video/BV1og4y1q7M4%EF%BC%88%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84B%E7%AB%99%E7%8B%82%E7%A5%9E%E8%AF%B4%EF%BC%89">https://www.bilibili.com/video/BV1og4y1q7M4（大名鼎鼎的B站狂神说）</a></p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><blockquote><p>官网：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p></blockquote><h4 id="1-1-容器较为官方的解释"><a href="#1-1-容器较为官方的解释" class="headerlink" title="1.1 容器较为官方的解释"></a>1.1 容器较为官方的解释</h4><p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p><ul><li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li><li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><h4 id="1-2-容器较为通俗的解释"><a href="#1-2-容器较为通俗的解释" class="headerlink" title="1.2 容器较为通俗的解释"></a>1.2 容器较为通俗的解释</h4><p><strong>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</strong></p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image-20210917111741745"></p><h3 id="2-虚拟化技术和容器化技术"><a href="#2-虚拟化技术和容器化技术" class="headerlink" title="2 虚拟化技术和容器化技术"></a>2 虚拟化技术和容器化技术</h3><h4 id="2-1-虚拟化技术"><a href="#2-1-虚拟化技术" class="headerlink" title="2.1 虚拟化技术"></a>2.1 虚拟化技术</h4><p>首先，Docker <strong>容器虚拟化</strong>技术为基础的软件，那么什么是虚拟化技术呢？</p><p>简单点来说，虚拟化技术可以这样定义：</p><blockquote><p>虚拟化技术是一种资源管理技术，是将计算机的各种<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%BA%90_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">实体资源</a>（<a href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98">内存</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4">磁盘空间</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E9%81%A9%E9%85%8D%E5%99%A8">网络适配器</a>等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p></blockquote><h4 id="2-2-Docker-基于-LXC-虚拟容器技术"><a href="#2-2-Docker-基于-LXC-虚拟容器技术" class="headerlink" title="2.2 Docker 基于 LXC 虚拟容器技术"></a>2.2 Docker 基于 LXC 虚拟容器技术</h4><p>Docker 技术是基于 LXC（Linux container- Linux 容器）虚拟容器技术的。</p><blockquote><p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p></blockquote><p>LXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 name space 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境。</p><p><strong>cgroup 和 namespace 介绍：</strong></p><ul><li><strong>namespace 是 Linux 内核用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。 （以上关于 namespace 介绍内容来自<a href="https://www.cnblogs.com/sparkdev/p/9365405.html">https://www.cnblogs.com/sparkdev/p/9365405.html</a> ，更多关于 namespace 的呢内容可以查看这篇文章 ）。</li><li><strong>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。</strong> （以上关于 CGroup 介绍内容来自 <a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html</a> ，更多关于 CGroup 的呢内容可以查看这篇文章 ）。</li></ul><p><strong>cgroup 和 namespace 两者对比：</strong></p><p>两者都是将进程进行分组，但是两者的作用还是有本质区别。namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制。</p><h3 id="3-Docker基本组成"><a href="#3-Docker基本组成" class="headerlink" title="3 Docker基本组成"></a>3 Docker基本组成</h3><p><strong>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</strong></p><ul><li><strong>镜像（Image）</strong></li><li><strong>容器（Container）</strong></li><li><strong>仓库（Repository）</strong></li></ul><p>理解了这三个概念，就理解了 Docker 的整个生命周期</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/Docker%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20210917114536633"></p><h3 id="4-Docker安装"><a href="#4-Docker安装" class="headerlink" title="4 Docker安装"></a>4 Docker安装</h3><h4 id="4-1-查看系统内核和系统信息"><a href="#4-1-查看系统内核和系统信息" class="headerlink" title="4.1 查看系统内核和系统信息"></a>4.1 查看系统内核和系统信息</h4><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /] # uname -r</span><br><span class="line">4.18.0-193.14.2.el8_2.x86_64</span><br><span class="line">[root@localhost /] # cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;8 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;8&quot;</span><br><span class="line">PLATFORM_ID=&quot;platform:el8&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 8 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:8&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-8&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;8&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;8&quot;</span><br></pre></td></tr></table></figure><h4 id="4-2-开始安装Docker"><a href="#4-2-开始安装Docker" class="headerlink" title="4.2 开始安装Docker"></a>4.2 开始安装Docker</h4><h5 id="4-2-1-卸载旧版本"><a href="#4-2-1-卸载旧版本" class="headerlink" title="4.2.1 卸载旧版本"></a>4.2.1 卸载旧版本</h5><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# yum remove docker \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-client \</span></span><br><span class="line"><span class="bash">&gt;                   docker-client-latest \</span></span><br><span class="line"><span class="bash">&gt;                   docker-common \</span></span><br><span class="line"><span class="bash">&gt;                   docker-latest \</span></span><br><span class="line"><span class="bash">&gt;                   docker-latest-logrotate \</span></span><br><span class="line"><span class="bash">&gt;                   docker-logrotate \</span></span><br><span class="line"><span class="bash">&gt;                   docker-engine</span></span><br><span class="line">No match for argument: docker</span><br><span class="line">No match for argument: docker-client</span><br><span class="line">No match for argument: docker-client-latest</span><br><span class="line">No match for argument: docker-common</span><br><span class="line">No match for argument: docker-latest</span><br><span class="line">No match for argument: docker-latest-logrotate</span><br><span class="line">No match for argument: docker-logrotate</span><br><span class="line">No match for argument: docker-engine</span><br><span class="line">没有软件包需要移除。</span><br><span class="line">依赖关系解决。</span><br><span class="line">无需任何处理。</span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><h5 id="4-2-2-下载依赖安装包"><a href="#4-2-2-下载依赖安装包" class="headerlink" title="4.2.2 下载依赖安装包"></a>4.2.2 下载依赖安装包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><h5 id="4-2-3-配置镜像仓库"><a href="#4-2-3-配置镜像仓库" class="headerlink" title="4.2.3 配置镜像仓库"></a>4.2.3 配置镜像仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">国外的地址</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置阿里云的Docker镜像仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# yum-config-manager \</span><br><span class="line">     --add-repo \</span><br><span class="line">     https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">     添加仓库自：https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.rep</span><br></pre></td></tr></table></figure><h5 id="4-2-4-更新yum软件包"><a href="#4-2-4-更新yum软件包" class="headerlink" title="4.2.4 更新yum软件包"></a>4.2.4 更新yum软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h5 id="4-2-5-下载docker"><a href="#4-2-5-下载docker" class="headerlink" title="4.2.5 下载docker"></a>4.2.5 下载docker</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io   # 安装社区版</span><br><span class="line">yum install docker-ee docker-ee-cli containerd.io   # 安装企业版</span><br></pre></td></tr></table></figure><p>一般情况下安装 <code>社区版</code></p><h4 id="4-3-启动Docker"><a href="#4-3-启动Docker" class="headerlink" title="4.3 启动Docker"></a>4.3 启动Docker</h4><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker       # 启动Docker</span><br><span class="line">docker version                   # 查看当前版本号，是否启动成功</span><br><span class="line">systemctl enable docker    # 设置开机自启动</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# systemctl start docker</span><br><span class="line">[root@localhost /]# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.7</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        f0df350</span><br><span class="line"> Built:             Wed Jun  2 11:56:24 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.7</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       b0f5bc3</span><br><span class="line">  Built:            Wed Jun  2 11:54:48 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.9</span><br><span class="line">  GitCommit:        e25210fe30a0a703442421b0f60afac609f950a3</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.1</span><br><span class="line">  GitCommit:        v1.0.1-0-g4144b63</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-Docker的HelloWorld"><a href="#4-4-Docker的HelloWorld" class="headerlink" title="4.4 Docker的HelloWorld"></a>4.4 Docker的HelloWorld</h4><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker run hello-world</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:df5f5184104426b65967e016ff2ac0bfcd44ad7899ca3bbcf8e44e4461491a9e</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line"></span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"></span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line"></span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"></span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><h4 id="5-Docker卸载"><a href="#5-Docker卸载" class="headerlink" title="5 Docker卸载"></a>5 Docker卸载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce docker-ce-cli containerd.io  # 卸载依赖</span><br><span class="line">rm -rf /var/lib/docker   # 删除资源  . /var/lib/docker是docker的默认工作路径</span><br></pre></td></tr></table></figure><h3 id="6-配置阿里云镜像"><a href="#6-配置阿里云镜像" class="headerlink" title="6 配置阿里云镜像"></a>6 配置阿里云镜像</h3><p>6.1 <strong>进入阿里云官网，搜索容器镜像服务</strong></p><p><img src="https://img-blog.csdnimg.cn/162855bcd35d45fca4f877334c1a2216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX1lhbk1pbmdYaW4=,size_16,color_FFFFFF,t_70"></p><h4 id="6-2-执行命令"><a href="#6-2-执行命令" class="headerlink" title="6.2 执行命令"></a>6.2 执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://axvfsf7e.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="7-Docker运行流程和原理"><a href="#7-Docker运行流程和原理" class="headerlink" title="7 Docker运行流程和原理"></a>7 Docker运行流程和原理</h3><h4 id="7-1-启动流程"><a href="#7-1-启动流程" class="headerlink" title="7.1 启动流程"></a>7.1 启动流程</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/docker%E7%9A%84run%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20210917132351022"></p><h4 id="7-2-运行原理"><a href="#7-2-运行原理" class="headerlink" title="7.2 运行原理"></a>7.2 运行原理</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/docker%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="image-20210917132434202"></p><h4 id="7-3-Docker整体架构"><a href="#7-3-Docker整体架构" class="headerlink" title="7.3 Docker整体架构"></a>7.3 Docker整体架构</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="image-20210917132516040"></p><h3 id="8-Docker常用命令"><a href="#8-Docker常用命令" class="headerlink" title="8 Docker常用命令"></a>8 Docker常用命令</h3><blockquote><p>命令的帮助文档地址:<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p></blockquote><h4 id="8-1-基本命令"><a href="#8-1-基本命令" class="headerlink" title="8.1 基本命令"></a>8.1 基本命令</h4><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version                        #查看docker的版本信息</span><br><span class="line">docker info                             #查看docker的系统信息,包括镜像和容器的数量</span><br><span class="line">docker 命令 --help                  #帮助命令(可查看可选的参数)</span><br><span class="line">docker COMMAND --help</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker info</span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.8.0)</span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 0</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 1</span><br><span class="line"> Images: 1</span><br><span class="line"> Server Version: 20.10.7</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-2-镜像命令"><a href="#8-2-镜像命令" class="headerlink" title="8.2 镜像命令"></a>8.2 镜像命令</h4><h5 id="8-2-1-docker-images-查看本地主机的所有镜像"><a href="#8-2-1-docker-images-查看本地主机的所有镜像" class="headerlink" title="8.2.1 docker images 查看本地主机的所有镜像"></a>8.2.1 <strong>docker images</strong> 查看本地主机的所有镜像</h5><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   5 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>列表参数介绍：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 解释:</span></span><br><span class="line">1.REPOSITORY  镜像的仓库源</span><br><span class="line">2.TAG  镜像的标签</span><br><span class="line">3.IMAGE ID 镜像的id</span><br><span class="line">4.CREATED 镜像的创建时间</span><br><span class="line">5.SIZE 镜像的大小</span><br><span class="line"><span class="section"># 可选参数</span></span><br><span class="line">-a/--all 列出所有镜像</span><br><span class="line">-q/--quiet 只显示镜像的id</span><br></pre></td></tr></table></figure><h5 id="8-2-2-docker-search-搜索镜像"><a href="#8-2-2-docker-search-搜索镜像" class="headerlink" title="8.2.2 docker search 搜索镜像"></a>8.2.2 <strong>docker search</strong> 搜索镜像</h5><p>示例：</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/docker%E7%9A%84search%E7%A4%BA%E4%BE%8B.png" alt="image-20210917132701117"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可选参数</span></span><br><span class="line">Search the Docker Hub for images</span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line"><span class="meta">#</span><span class="bash">搜索收藏数大于3000的镜像</span></span><br><span class="line">[root@localhost ~]# docker search mysql --filter=STARS=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation...   10308     [OK]</span><br><span class="line">mariadb   MariaDB is a community-developed fordockerk of MyS...   3819      [OK]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">搜索官方的</span></span><br><span class="line">[root@localhost /]# docker search mysql -f &quot;is-official=true&quot;</span><br><span class="line">NAME         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql        MySQL is a widely used, open-source relation…   11419     [OK]       </span><br><span class="line">mariadb      MariaDB Server is a high performing open sou…   4339      [OK]       </span><br><span class="line">percona      Percona Server is a fork of the MySQL relati…   554       [OK]       </span><br><span class="line">phpmyadmin   phpMyAdmin - A web interface for MySQL and M…   322       [OK]   </span><br></pre></td></tr></table></figure><h5 id="8-2-3-docker-pull-镜像名-tag-下载镜像"><a href="#8-2-3-docker-pull-镜像名-tag-下载镜像" class="headerlink" title="8.2.3 docker pull 镜像名[:tag] 下载镜像"></a>8.2.3 <strong>docker pull 镜像名[:tag]</strong> 下载镜像</h5><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">33847f680f63: Pull complete</span><br><span class="line">5cb67864e624: Pull complete</span><br><span class="line">1a2b594783f5: Pull complete</span><br><span class="line">b30e406dd925: Pull complete</span><br><span class="line">48901e306e4c: Pull complete</span><br><span class="line">603d2b7147fd: Pull complete</span><br><span class="line">802aa684c1c4: Pull complete</span><br><span class="line">5b5a19178915: Pull complete</span><br><span class="line">f9ce7411c6e4: Pull complete</span><br><span class="line">f51f6977d9b2: Pull complete</span><br><span class="line">aeb6b16ce012: Pull complete</span><br><span class="line">Digest: sha256:be70d18aedc37927293e7947c8de41ae6490ecd4c79df1db40d1b5b5af7d9596</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><h5 id="8-2-4-docker-rmi-删除镜像"><a href="#8-2-4-docker-rmi-删除镜像" class="headerlink" title="8.2.4 docker rmi 删除镜像"></a>8.2.4 <strong>docker rmi</strong> 删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.删除指定的镜像id</span></span><br><span class="line">[root@localhost ~]# docker rmi -f  镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash">2.删除多个镜像id</span></span><br><span class="line">[root@localhost ~]# docker rmi -f  镜像id 镜像id 镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash">3.删除全部的镜像id</span></span><br><span class="line">[root@localhost ~]# docker rmi -f  $(docker images -aq)</span><br></pre></td></tr></table></figure><h4 id="8-3-容器命令"><a href="#8-3-容器命令" class="headerlink" title="8.3 容器命令"></a>8.3 容器命令</h4><h5 id="8-3-1-docker-run-可选参数-image-运行容器"><a href="#8-3-1-docker-run-可选参数-image-运行容器" class="headerlink" title="8.3.1 docker run [可选参数] image 运行容器"></a>8.3.1 docker run [可选参数] image 运行容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line">--name=&quot;名字&quot;           指定容器名字</span><br><span class="line">-d                     后台方式运行</span><br><span class="line">-it                    使用交互方式运行,进入容器查看内容</span><br><span class="line">-p                     指定容器的端口</span><br><span class="line">( -p ip:主机端口:容器端口  配置主机端口映射到容器端口</span><br><span class="line">  -p 主机端口:容器端口</span><br><span class="line">  -p 容器端口)</span><br><span class="line">-P                     随机指定端口(大写的P)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker run 8cf625070931</span><br><span class="line">2021-08-03 06:48:07+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.35-1debian10 started.</span><br><span class="line"></span><br><span class="line">2021-08-03 06:48:07+00:00 [Note] [Entrypoint]: Switching to dedicated user &#x27;mysql&#x27;</span><br><span class="line">2021-08-03 06:48:07+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.35-1debian10 started.</span><br><span class="line"></span><br><span class="line">2021-08-03 06:48:07+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified</span><br><span class="line">    You need to specify one of the following:</span><br><span class="line">    - MYSQL_ROOT_PASSWORD</span><br><span class="line">    - MYSQL_ALLOW_EMPTY_PASSWORD</span><br><span class="line">    - MYSQL_RANDOM_ROOT_PASSWORD</span><br></pre></td></tr></table></figure><h5 id="8-3-2-进入容器"><a href="#8-3-2-进入容器" class="headerlink" title="8.3.2 进入容器"></a>8.3.2 进入容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker run -it [容器ID] /bin/bash</span><br></pre></td></tr></table></figure><h5 id="8-3-3-exit-退出容器"><a href="#8-3-3-exit-退出容器" class="headerlink" title="8.3.3 exit 退出容器"></a>8.3.3 exit 退出容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">exit</span> 停止并退出容器（后台方式运行则仅退出）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Ctrl+P+Q  不停止容器退出</span></span><br><span class="line">[root@bd1b8900c547 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]#</span><br></pre></td></tr></table></figure><h5 id="8-3-4-docker-ps列出容器"><a href="#8-3-4-docker-ps列出容器" class="headerlink" title="8.3.4 docker ps列出容器"></a>8.3.4 docker ps列出容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker ps</span> </span><br><span class="line">     # 列出当前正在运行的容器</span><br><span class="line">-a   # 列出所有容器的运行记录</span><br><span class="line">-n=? # 显示最近创建的n个容器</span><br><span class="line">-q   # 只显示容器的编号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">bca129320bb5   centos         &quot;/bin/bash&quot;   4 minutes ago   Exited (0) 3 minutes ago             optimistic_shtern</span><br><span class="line">bd1b8900c547   centos         &quot;/bin/bash&quot;   6 minutes ago   Exited (0) 5 minutes ago             cool_tesla</span><br><span class="line">cf6adbf1b506   bf756fb1ae65   &quot;/hello&quot;      5 hours ago     Exited (0) 5 hours ago               optimistic_darwin</span><br></pre></td></tr></table></figure><h5 id="8-3-5-删除容器"><a href="#8-3-5-删除容器" class="headerlink" title="8.3.5 删除容器"></a>8.3.5 删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id                 #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)   #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm #删除所有的容器</span><br></pre></td></tr></table></figure><h5 id="8-3-6-启动和重启容器命令"><a href="#8-3-6-启动和重启容器命令" class="headerlink" title="8.3.6 启动和重启容器命令"></a>8.3.6 启动和重启容器命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id          #启动容器</span><br><span class="line">docker restart 容器id        #重启容器</span><br><span class="line">docker stop 容器id           #停止当前运行的容器</span><br><span class="line">docker kill 容器id           #强制停止当前容器</span><br></pre></td></tr></table></figure><h4 id="8-4-其他命令"><a href="#8-4-其他命令" class="headerlink" title="8.4 其他命令"></a>8.4 其他命令</h4><h5 id="8-4-1-查看日志"><a href="#8-4-1-查看日志" class="headerlink" title="8.4.1 查看日志"></a>8.4.1 查看日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker logs --help</span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line"></span><br><span class="line">常用：</span><br><span class="line">docker logs -tf 容器id</span><br><span class="line">docker logs --tail number 容器id #num为要显示的日志条数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker容器后台运行，必须要有一个前台的进程，否则会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash">编写shell脚本循环执行，使得centos容器保持运行状态</span></span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker run -d centos /bin/sh -c &quot;while true;do echo hi;sleep 5;done&quot;</span><br><span class="line">c703b5b1911ff84d584390263a35707b6024816e1f46542b61918a6327a570dc</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">c703b5b1911f   centos    &quot;/bin/sh -c &#x27;while t…&quot;   13 seconds ago   Up 10 seconds             pedantic_banach</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker logs -tf --tail 10 c703b5b1911f</span><br><span class="line">2020-12-27T03:34:07.255599560Z hi</span><br><span class="line">2020-12-27T03:34:12.257641517Z hi</span><br><span class="line">2020-12-27T03:34:17.259706294Z hi</span><br><span class="line">2020-12-27T03:34:22.261693707Z hi</span><br><span class="line">2020-12-27T03:34:27.262609289Z hi</span><br><span class="line">2020-12-27T03:34:32.267862677Z hi</span><br><span class="line">2020-12-27T03:34:37.270382873Z hi</span><br><span class="line">2020-12-27T03:34:42.272414182Z hi</span><br><span class="line">2020-12-27T03:34:47.274823243Z hi</span><br><span class="line">2020-12-27T03:34:52.277419274Z hi</span><br></pre></td></tr></table></figure><h5 id="8-4-2-查看容器中进程信息"><a href="#8-4-2-查看容器中进程信息" class="headerlink" title="8.4.2 查看容器中进程信息"></a>8.4.2 查看容器中进程信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker top c703b5b1911f</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                11156               11135               0                   11:31               ?                   00:00:00            /bin/sh -c while true;do echo hi;sleep 5;done</span><br><span class="line">root                11886               11156               0                   11:43               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5</span><br></pre></td></tr></table></figure><h5 id="8-4-3-查看容器的元数据"><a href="#8-4-3-查看容器的元数据" class="headerlink" title="8.4.3 查看容器的元数据"></a>8.4.3 查看容器的元数据</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker inspect 容器id</span><br></pre></td></tr></table></figure><h5 id="8-4-4-进入当前正在运行的容器"><a href="#8-4-4-进入当前正在运行的容器" class="headerlink" title="8.4.4 进入当前正在运行的容器"></a>8.4.4 进入当前正在运行的容器</h5><p>方式一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it c703b5b1911f /bin/bash</span><br><span class="line">[root@c703b5b1911f /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@c703b5b1911f /]# ps -ef      </span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 03:31 ?        00:00:00 /bin/sh -c while true;do echo hi;sleep 5;done</span><br><span class="line">root       279     0  0 03:54 pts/0    00:00:00 /bin/bash</span><br><span class="line">root       315     1  0 03:56 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 5</span><br><span class="line">root       316   279  0 03:56 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker attach c703b5b1911f</span><br></pre></td></tr></table></figure><p>docker exec 进入容器后开启一个新的终端，可以在里面操作</p><p>docker attach 进入容器正在执行的终端，不会启动新的进程</p><h5 id="8-4-5-拷贝容器文件到主机"><a href="#8-4-5-拷贝容器文件到主机" class="headerlink" title="8.4.5 拷贝容器文件到主机"></a>8.4.5 拷贝容器文件到主机</h5><p>拷贝容器的文件到主机中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it c703b5b1911f /bin/bash</span><br><span class="line">[root@c703b5b1911f /]# cd home</span><br><span class="line">[root@c703b5b1911f home]# ls</span><br><span class="line"><span class="meta">#</span><span class="bash">touch 新建文件</span></span><br><span class="line">[root@c703b5b1911f home]# touch test.java</span><br><span class="line">[root@c703b5b1911f home]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@c703b5b1911f home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">c703b5b1911f   centos    &quot;/bin/sh -c &#x27;while t…&quot;   35 minutes ago   Up 35 minutes             pedantic_banach</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker cp c703b5b1911f:/home/test.java /home</span><br><span class="line">[root@iZwz99sm8v95sckz8bd2c4Z ~]# ls /home</span><br><span class="line">hai  pan  test.java</span><br></pre></td></tr></table></figure><h4 id="8-5-常用命令小结"><a href="#8-5-常用命令小结" class="headerlink" title="8.5 常用命令小结"></a>8.5 常用命令小结</h4><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210917133318715.png" alt="image-20210917133318715"></p><h3 id="9-Docker图形化管理工具"><a href="#9-Docker图形化管理工具" class="headerlink" title="9 Docker图形化管理工具"></a>9 Docker图形化管理工具</h3><h5 id="9-1-Docker-UI"><a href="#9-1-Docker-UI" class="headerlink" title="9.1 Docker UI"></a>9.1 Docker UI</h5><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search dockeruidocker pull abh1nav/dockeruidocker run -d --privileged --name dockerui -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock abh1nav/dockerui  #放开物理机的9000端口对应Docker容器的9000端口</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z /]# docker search dockeruiNAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDabh1nav/dockerui               An updated version of crosbymichael/dockerui…   99                   [OK]kevan/dockerui                 Deprecated: Use  uifd/ui-for-docker             15                   [OK]microbox/dockerui              Trusted Automated dockerui image (16MB size)    8               ......[root@iZ1608aqb7ntn9Z /]# docker pull abh1nav/dockeruiUsing default tag: latestlatest: Pulling from abh1nav/dockeruiImage docker.io/abh1nav/dockerui:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/a3ed95caeb02: Pull complete 5d3df020ecd3: Pull complete bebf5a3b4dfb: Pull complete e4452c0fe72b: Pull complete 6167d9726b07: Pull complete 53ebae19a314: Pull complete Digest: sha256:a9c6c5393f561a0f42f41cfa80572b666e745d9b419569c42bac1e5cf9ceda32Status: Downloaded newer image for abh1nav/dockerui:latestdocker.io/abh1nav/dockerui:latest[root@iZ1608aqb7ntn9Z /]#  docker run -d --privileged --name dockerui -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock abh1nav/dockeruie2352bcf98475e17e4d25cd2f30324c4bd1465927b2452126c94d03052a11c91</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问：http://ip地址:9000</span><br></pre></td></tr></table></figure><h5 id="9-2-Shipyard"><a href="#9-2-Shipyard" class="headerlink" title="9.2 Shipyard"></a>9.2 Shipyard</h5><h5 id="9-3-Portainer"><a href="#9-3-Portainer" class="headerlink" title="9.3 Portainer"></a>9.3 Portainer</h5><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search portainerdocker pull portainer/portainerdocker run -d --name portainerUI -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z /]# docker search portainerNAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDportainer/portainer              This Repo is now deprecated, use portainer/p…   2109                 portainer/portainer-ce           Portainer CE - Making Docker and Kubernetes …   635                  portainer/agent                  An agent used to manage all the resources in…   111                  portainer/templates              App Templates for Portainer http://portainer…   23             ......                  [root@iZ1608aqb7ntn9Z /]# docker pull portainer/portainerUsing default tag: latestlatest: Pulling from portainer/portainer94cfa856b2b1: Pull complete 49d59ee0881a: Pull complete a2300fd28637: Pull complete Digest: sha256:fb45b43738646048a0a0cc74fcee2865b69efde857e710126084ee5de9be0f3fStatus: Downloaded newer image for portainer/portainer:latestdocker.io/portainer/portainer:latest[root@iZ1608aqb7ntn9Z /]# docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainerabbf483bd3df0e30eaeb3a0dd708776a6fbbf055e2c87bcb84177df7e86c8ac2</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问：http://ip地址:8088</span><br></pre></td></tr></table></figure><h3 id="10-常见容器部署—Nginx-Tomcat-ES"><a href="#10-常见容器部署—Nginx-Tomcat-ES" class="headerlink" title="10 常见容器部署—Nginx,Tomcat,ES"></a>10 常见容器部署—Nginx,Tomcat,ES</h3><h5 id="10-1-Nginx"><a href="#10-1-Nginx" class="headerlink" title="10.1 Nginx"></a>10.1 Nginx</h5><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker search nginx  # 查找[root@iZ1608aqb7ntn9Z ~]# docker pull nginx    # 下载[root@iZ1608aqb7ntn9Z ~]# docker run -d --name nginx -p 9000:80 nginx   # 启动# 备注-d 后台运行--name 给容器命名-p 3334:80 将宿主机的端口3334映射到该容器的80端口</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker search nginxNAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDnginx                             Official build of Nginx.                        15256     [OK]       jwilder/nginx-proxy               Automated Nginx reverse proxy for docker con…   2054                 [OK]richarvey/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   815                  [OK]......[root@iZ1608aqb7ntn9Z ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx33847f680f63: Already exists dbb907d5159d: Pull complete 8a268f30c42a: Pull complete b10cf527a02d: Pull complete c90b090c213b: Pull complete 1f41b2f2bf94: Pull complete Digest: sha256:8f335768880da6baf72b70c701002b45f4932acae8d574dedfddaf967fc3ac90Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@iZ1608aqb7ntn9Z ~]# docker run -d --name nginx -p 9000:80 nginxe2f7da87581a49d74096814ea8a8ea4dcc739c398f78f9a187807f9e34e8133e</span><br></pre></td></tr></table></figure><p>测试访问：</p><p><img src="https://img-blog.csdnimg.cn/29aada62bca3418ead6b5638a6e598ef.png"></p><h5 id="10-2-Tomcat"><a href="#10-2-Tomcat" class="headerlink" title="10.2 Tomcat"></a>10.2 Tomcat</h5><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker search tomcat  # 查找[root@iZ1608aqb7ntn9Z ~]# docker pull tomcat    # 下载[root@iZ1608aqb7ntn9Z ~]# docker run -d --name tomcat -p 9000:8080 tomcat   # 启动</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ1608aqb7ntn9Z ~]# docker search tomcatNAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDtomcat                        Apache Tomcat is an open source implementati…   3086      [OK]       tomee                         Apache TomEE is an all-Apache Java EE certif…   91        [OK]    [root@iZ1608aqb7ntn9Z ~]# docker pull tomcatUsing default tag: latestlatest: Pulling from library/tomcat627b765e08d1: Pull complete c040670e5e55: Pull complete 073a180f4992: Pull complete bf76209566d0: Pull complete f10db7ba7580: Pull complete 5b2f970878fa: Pull complete ed434bfebf18: Pull complete f6c437110aa9: Pull complete a772951f83db: Pull complete 752225c3768e: Pull complete Digest: sha256:6e40250d8fac4eca05c2067cb81f79427e4ddbaf4e78d5ecd21c35e8c5f2bfcfStatus: Downloaded newer image for tomcat:latestdocker.io/library/tomcat:latest[root@iZ1608aqb7ntn9Z ~]# docker run -d --name tomcat -p 9000:8080 tomcatf41a3e8b640da739d0b4b9dc161dc59ceb16d9ff899769834cdb4954a954374eps #有些tomcat是最小运行环境所以webapps下没有东西 可以吧webapps.dist下的文件复制到webapps下</span><br></pre></td></tr></table></figure><p>测试访问：</p><p><img src="https://img-blog.csdnimg.cn/986c34efe42844cbb25fa7bdc2de4e2a.png"></p><h5 id="10-3-ES"><a href="#10-3-ES" class="headerlink" title="10.3 ES"></a>10.3 ES</h5><p>添加 ‘-e ES_JAVA_OPTS=”-Xms128m -Xmx512m” ‘ 配置ElasticSearch的虚拟机占用的内存大小。</p><p>docker stats 查看资源占用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms128m -Xmx512m&quot;</span> elasticsearch:7.6.2[root@iZwz99sm8v95sckz8bd2c4Z ~]<span class="comment"># docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx512m&quot; elasticsearch:7.6.23b8cd4991814896c523ee67b84ce198e32bd82b1a62d512b198138a58ca946f1[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS         PORTS                                            NAMES3b8cd4991814   elasticsearch:7.6.2   &quot;/usr/local/bin/dock…&quot;   10 seconds ago   Up 6 seconds   0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   elasticsearch01[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker stats</span></span></span><br></pre></td></tr></table></figure><h5 id="10-4-端口暴露的原理"><a href="#10-4-端口暴露的原理" class="headerlink" title="10.4 端口暴露的原理"></a>10.4 端口暴露的原理</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/ityoung09/images/raw/master/images/%E7%AB%AF%E5%8F%A3%E6%9A%B4%E9%9C%B2%E5%8E%9F%E7%90%86.png" alt="image-20210917133637958"></h5><p>10.5Kibana</p><p><code>思考</code>：使用kibanna连接es？思考网络如何才能连接过去</p><p><img src="https://gitee.com/ityoung09/images/raw/master/images/image-20210917143009070.png" alt="image-20210917143009070"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1og4y1q7M4%EF%BC%88%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84B%E7%AB%99%E7</summary>
      
    
    
    
    <category term="Docker" scheme="http://www.ityoung.xyz/categories/Docker/"/>
    
    
    <category term="Linux" scheme="http://www.ityoung.xyz/tags/Linux/"/>
    
    <category term="容器" scheme="http://www.ityoung.xyz/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>logback的配置文件</title>
    <link href="http://www.ityoung.xyz/posts/63692/"/>
    <id>http://www.ityoung.xyz/posts/63692/</id>
    <published>2021-08-17T07:36:55.000Z</published>
    <updated>2021-08-17T07:44:11.188Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml</span> <span class="string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;configuration</span> <span class="string">scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt;</span></span><br><span class="line">    <span class="attr">&lt;contextName&gt;logback&lt;/contextName&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--配置日志文件输出路径，下面用$&#123;path&#125;占位使用&#125;--&gt;</span></span><br><span class="line">    <span class="meta">&lt;property</span> <span class="string">name=&quot;path&quot; value=&quot;E:/logs/slogback&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">&lt;!--0.</span> <span class="string">日志格式和颜色渲染 --&gt;</span></span><br><span class="line">    <span class="meta">&lt;!--</span> <span class="string">彩色日志依赖的渲染类 --&gt;</span></span><br><span class="line">    <span class="meta">&lt;conversionRule</span> <span class="string">conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;</span></span><br><span class="line">    <span class="meta">&lt;conversionRule</span> <span class="string">conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;</span></span><br><span class="line">    <span class="meta">&lt;conversionRule</span> <span class="string">conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;</span></span><br><span class="line">    <span class="meta">&lt;!--</span> <span class="string">彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="meta">&lt;property</span> <span class="string">name=&quot;local_pattern&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--文件日志格式--&gt;</span></span><br><span class="line">    <span class="meta">&lt;property</span> <span class="string">name=&quot;file_pattern&quot; value=&quot;%d - %msg%n&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">    <span class="meta">&lt;appender</span> <span class="string">name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class="line">        <span class="meta">&lt;filter</span> <span class="string">class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;level&gt;debug&lt;/level&gt;</span></span><br><span class="line">        <span class="attr">&lt;/filter&gt;</span></span><br><span class="line">        <span class="attr">&lt;encoder&gt;</span></span><br><span class="line">            <span class="attr">&lt;Pattern&gt;</span></span><br><span class="line">                <span class="attr">$&#123;local_pattern&#125;</span></span><br><span class="line">            <span class="attr">&lt;/Pattern&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">设置字符集 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;charset&gt;UTF-8&lt;/charset&gt;</span></span><br><span class="line">        <span class="attr">&lt;/encoder&gt;</span></span><br><span class="line">    <span class="attr">&lt;/appender&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--只保存info日志--&gt;</span></span><br><span class="line">    <span class="meta">&lt;appender</span> <span class="string">name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;filter</span> <span class="string">class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;level&gt;INFO&lt;/level&gt;</span></span><br><span class="line">            <span class="attr">&lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span></span><br><span class="line">            <span class="attr">&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span></span><br><span class="line">        <span class="attr">&lt;/filter&gt;</span></span><br><span class="line">        <span class="attr">&lt;encoder&gt;</span></span><br><span class="line">            <span class="attr">&lt;pattern&gt;</span></span><br><span class="line">                <span class="attr">$&#123;file_pattern&#125;</span></span><br><span class="line">            <span class="attr">&lt;/pattern&gt;</span></span><br><span class="line">            <span class="attr">&lt;charset&gt;UTF-8&lt;/charset&gt;</span></span><br><span class="line">        <span class="attr">&lt;/encoder&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--滚动输出策略--&gt;</span></span><br><span class="line">        <span class="meta">&lt;rollingPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="attr">&lt;fileNamePattern&gt;$&#123;path&#125;/info/info-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">文件大小分割，超过配置大小就建当天新的日志文件 --&gt;</span></span><br><span class="line">            <span class="meta">&lt;timeBasedFileNamingAndTriggeringPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span></span><br><span class="line">                <span class="attr">&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span></span><br><span class="line">            <span class="attr">&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">保存7天 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;MaxHistory&gt;7&lt;/MaxHistory&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">总日志大小 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</span></span><br><span class="line">        <span class="attr">&lt;/rollingPolicy&gt;</span></span><br><span class="line">    <span class="attr">&lt;/appender&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--只保存warn日志--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">&lt;appender</span> <span class="string">name=&quot;fileWarnLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;filter</span> <span class="string">class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;level&gt;WARN&lt;/level&gt;</span></span><br><span class="line">            <span class="attr">&lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span></span><br><span class="line">            <span class="attr">&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span></span><br><span class="line">        <span class="attr">&lt;/filter&gt;</span></span><br><span class="line">        <span class="attr">&lt;encoder&gt;</span></span><br><span class="line">            <span class="attr">&lt;pattern&gt;</span></span><br><span class="line">                <span class="attr">$&#123;file_pattern&#125;</span></span><br><span class="line">            <span class="attr">&lt;/pattern&gt;</span></span><br><span class="line">            <span class="attr">&lt;charset&gt;UTF-8&lt;/charset&gt;</span></span><br><span class="line">        <span class="attr">&lt;/encoder&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--滚动输出策略--&gt;</span></span><br><span class="line">        <span class="meta">&lt;rollingPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="attr">&lt;fileNamePattern&gt;$&#123;path&#125;/warn/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">文件大小分割，超过配置大小就建当天新的日志文件 --&gt;</span></span><br><span class="line">            <span class="meta">&lt;timeBasedFileNamingAndTriggeringPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span></span><br><span class="line">                <span class="attr">&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span></span><br><span class="line">            <span class="attr">&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">保存30天 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;MaxHistory&gt;30&lt;/MaxHistory&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">总日志大小 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</span></span><br><span class="line">        <span class="attr">&lt;/rollingPolicy&gt;</span></span><br><span class="line">    <span class="attr">&lt;/appender&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--只保存error日志--&gt;</span></span><br><span class="line">    <span class="meta">&lt;appender</span> <span class="string">name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;filter</span> <span class="string">class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;level&gt;ERROR&lt;/level&gt;</span></span><br><span class="line">        <span class="attr">&lt;/filter&gt;</span></span><br><span class="line">        <span class="attr">&lt;encoder&gt;</span></span><br><span class="line">            <span class="attr">&lt;pattern&gt;</span></span><br><span class="line">                <span class="attr">$&#123;file_pattern&#125;</span></span><br><span class="line">            <span class="attr">&lt;/pattern&gt;</span></span><br><span class="line">            <span class="attr">&lt;charset&gt;UTF-8&lt;/charset&gt;</span></span><br><span class="line">        <span class="attr">&lt;/encoder&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--滚动输出策略--&gt;</span></span><br><span class="line">        <span class="meta">&lt;rollingPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span></span><br><span class="line">            <span class="attr">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="attr">&lt;fileNamePattern&gt;$&#123;path&#125;/error/error-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">文件大小分割，超过配置大小就建当天新的日志文件 --&gt;</span></span><br><span class="line">            <span class="meta">&lt;timeBasedFileNamingAndTriggeringPolicy</span> <span class="string">class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span></span><br><span class="line">                <span class="attr">&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span></span><br><span class="line">            <span class="attr">&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">保存30天 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;MaxHistory&gt;30&lt;/MaxHistory&gt;</span></span><br><span class="line">            <span class="meta">&lt;!--</span> <span class="string">总日志大小 --&gt;</span></span><br><span class="line">            <span class="attr">&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</span></span><br><span class="line">        <span class="attr">&lt;/rollingPolicy&gt;</span></span><br><span class="line">    <span class="attr">&lt;/appender&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--local环境下，仅控制台打印，配置为彩色--&gt;</span></span><br><span class="line">    <span class="meta">&lt;springProfile</span> <span class="string">name=&quot;local&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;root</span> <span class="string">level=&quot;debug&quot;&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;consoleLog&quot;/&gt;</span></span><br><span class="line">        <span class="attr">&lt;/root&gt;</span></span><br><span class="line">    <span class="attr">&lt;/springProfile&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--dev环境输出到文件--&gt;</span></span><br><span class="line">    <span class="meta">&lt;springProfile</span> <span class="string">name=&quot;dev&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;root</span> <span class="string">level=&quot;info&quot;&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileInfoLog&quot;/&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileWarnLog&quot;/&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileErrorLog&quot;/&gt;</span></span><br><span class="line">        <span class="attr">&lt;/root&gt;</span></span><br><span class="line">    <span class="attr">&lt;/springProfile&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;!--pro环境输出到文件--&gt;</span></span><br><span class="line">    <span class="meta">&lt;springProfile</span> <span class="string">name=&quot;pro&quot;&gt;</span></span><br><span class="line">        <span class="meta">&lt;root</span> <span class="string">level=&quot;info&quot;&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileInfoLog&quot;/&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileWarnLog&quot;/&gt;</span></span><br><span class="line">            <span class="meta">&lt;appender-ref</span> <span class="string">ref=&quot;fileErrorLog&quot;/&gt;</span></span><br><span class="line">        <span class="attr">&lt;/root&gt;</span></span><br><span class="line">    <span class="attr">&lt;/springProfile&gt;</span></span><br><span class="line"><span class="attr">&lt;/configuration&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
    <category term="日志" scheme="http://www.ityoung.xyz/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="http://www.ityoung.xyz/posts/24112/"/>
    <id>http://www.ityoung.xyz/posts/24112/</id>
    <published>2021-04-18T04:51:27.000Z</published>
    <updated>2021-04-18T04:57:21.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><blockquote><p>进程(Process)和线程(Thread的概念</p></blockquote><p>进程是系统执行程序的一次执行过程,是系统资源分配的单位</p><p>线程则是CPU调度和执行的单位</p><p><code>一个进程可以有若干个线程,当然一个进程至少得拥有一个线程</code></p><ul><li><strong>线程就是独立的执行路径；</strong></li><li>在线程运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程(Java垃圾回收)；</li><li>main()称之为主线程，为系统的入口，用于执行整个程序；</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</li><li>线程会带来额外的开销，如cpu调度时间，并发控制开销。</li><li><code>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</code></li></ul><blockquote><p>单线程和多线程的图解</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20210111205445.png" alt="Snipaste_2021-01-11_18-28-47"><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20210111205500.png" alt="Snipaste_2021-01-11_18-29-08"></p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol><li><p><strong>继承Thread类(重点)</strong></p><ul><li>自定义线程类继承*Thread类</li><li>重写run()方法<code>线程的方法体</code></li><li>调用start()方法开启线程</li></ul></li><li><p><strong>实现Runnable接口(重点)</strong></p><ul><li><p>定义MyRunnable类实现Runnable接口</p></li><li><p>实现run()方法,编写线程执行体</p></li><li><p>创建线程对象Thread对象将自定义Runnable类放入线程对象参数中,在调用satrt()方法启动线程<code>Thread(MyRunnable)</code></p><p><code>推荐使用实现Runnable接口,因为Java的单继承局限性</code></p></li></ul></li><li><p><strong>实现Callable接口(了解)</strong></p><ul><li><p>任务类实现Callable接口</p></li><li><p>重写call()方法,需要抛出异常</p></li><li><p>创建目标对象：chuju cj = new chuju();</p></li><li><p>创建线程池服务：ExecutorService es = Executors.newCachedThreadPool();</p></li><li><p>提交任务：Future<Boolean> future = es.submit(cj);</p></li><li><p>获取子线程中任务的执行结果：Boolean rs = future.get()</p></li><li><p>关闭服务：es.shutdownNow();</p><p><code>优点:可以定义返回值,能抛出异常</code></p></li></ul></li></ol><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li>创建状态</li><li>就绪状态</li><li>阻塞状态</li><li>运行状态</li><li>死亡状态</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20210112021446.png" alt="image-20210112021446617"></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20210112022703.png" alt="image-20210112022703393"></p><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority(int new Priority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millisecond)</td><td>在指定的毫秒数内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象,并执行其他线程</td></tr><tr><td>void interrupt()</td><td>终端线程,别用这个</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table><h4 id="线程休眠-sleep"><a href="#线程休眠-sleep" class="headerlink" title="线程休眠 sleep()"></a>线程休眠 sleep()</h4><ul><li>sleep(毫秒数)指定当前线程停止的实践</li><li>sleep()存在异常InteruptedException</li><li>sleep()实践到达后线程进入就绪状态</li><li>sleep()可以模拟网络延时,倒计时等</li><li>每一个对象都有一个锁,sleep不会释放锁</li></ul><h4 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让 yield()"></a>线程礼让 yield()</h4><ul><li>礼让线程,让当前正在执行的线程暂停,但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让CPU重新调度,礼让不一定成功,看CPU心情</li></ul><h4 id="线程强制执行-join"><a href="#线程强制执行-join" class="headerlink" title="线程强制执行 join()"></a>线程强制执行 join()</h4><ul><li>Join合并线程,待此线程执行完成后,在执行其他线程,其他线程阻塞</li><li>可以想象成插队</li></ul><p><code>执行join之前线程是并行的</code></p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程;线程调度器按照优先级决定该调度哪个线程来执行</li><li>线程的优先级用数字来表示,范围从1~10<ul><li>Thread.MIN_PRIORITY = 1</li><li>Thread.MAX_PRIORITY= 10</li><li>Thread.NORM_PRIORITY = 5</li></ul></li><li>使用getPriority()和setPriority()来获取或改变优先级</li></ul><h4 id="守护线程setDeamon"><a href="#守护线程setDeamon" class="headerlink" title="守护线程setDeamon()"></a>守护线程setDeamon()</h4><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>如后台记录操作日志,监控内存,垃圾回收</li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul><li><p>处理多线程问题时,多个线程访问同一个对象,并且某些线程还想修改这个对象,这时候我们就需要线程同步,线程同步其实是一种等待机制,多个需要同时访问此对象的线程进入这个对象的等待池形成队列,等待前面的线程使用完毕,下一个线程在使用</p></li><li><p>由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问的冲突问题,为了保证数据在方法中被访问时的正确性,在访问时加入</p><p>锁机制syncronized</p><p>,当一个线程获得对象的排他锁,独占资源,其他线程必须等待,使用后释放锁即可,存在一下问题</p><ul><li>一个线程持有锁会导致其他所有需要此锁的进程挂起</li><li>在多线程竞争的情况下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置,引起性能问题</li></ul></li></ul><h4 id="同步方法和同步块"><a href="#同步方法和同步块" class="headerlink" title="同步方法和同步块"></a>同步方法和同步块</h4><ul><li>同步块: synchronized(obj){}</li><li>obj称之为同步监视器<ul><li>obj可以是任何对象,但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器,因为同步方法中的同步监视器就是this,就是这个对象本身,或者是class</li></ul></li><li>同步监视器的执行过程<ul><li>第一个线程访问,锁定同步监视器,执行其中的代码</li><li>第二个线程访问,发现同步监视器被锁定,无法访问</li><li>第一个线程访问完毕,解锁同步监视器</li><li>第二个线程访问,发现同步监视器没有锁,然后锁定并访问</li></ul></li><li>同步方法在方法上添加synchronized关键子,锁的是对象本身</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>多个线程各自占有一些共享资源,并且互相等待其他线程占有的资源释放才能运行,而导致两个或者多个线程都在等待对方释放资源,都停止执行的情形,某一个同步块同时拥有”两个以上的对象锁”时,就可能发生死锁现象</li></ul><h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><ul><li>互斥条件: 一个资源每次只能被一个进程使用</li><li>请求保持条件: 一个进程因请求资源而阻塞时.对以获得的资源保持不放</li><li>不剥夺条件: 进程已获得的资源,在未使用完之前,不能强行剥夺</li><li>循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><ul><li>从JDK1.5开始,java提供了更为强大的线程同步机制——通过显示定义同步锁对象来实现同步,同步锁使用lock对象来充当</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock类实现了Lock,它拥有与synchronized相同的并发性和内存语义,在实现线程安全的控制中.比较常用的是ReentrantLock,可以显示加锁,释放锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;进程(Process)和线程(Thread的概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程是</summary>
      
    
    
    
    <category term="Java" scheme="http://www.ityoung.xyz/categories/Java/"/>
    
    
    <category term="Java高级" scheme="http://www.ityoung.xyz/tags/Java%E9%AB%98%E7%BA%A7/"/>
    
    <category term="多线程" scheme="http://www.ityoung.xyz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性—lambda表达式</title>
    <link href="http://www.ityoung.xyz/posts/19458/"/>
    <id>http://www.ityoung.xyz/posts/19458/</id>
    <published>2021-04-15T08:50:34.000Z</published>
    <updated>2021-04-23T09:27:09.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h4><p>Lambda 表达式（lambda expression）是一个<a href="https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/4337265">匿名函数</a>，Lambda表达式基于数学中的<a href="https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97">λ演算</a>得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示<a href="https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873">闭包</a>（注意和数学传统意义上的不同）。</p><h4 id="lambda的优点和特性"><a href="#lambda的优点和特性" class="headerlink" title="lambda的优点和特性"></a>lambda的优点和特性</h4><p><strong>优点</strong>:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/h3&gt;&lt;h4 id=&quot;什么是lambda表达式&quot;&gt;&lt;a href=&quot;#什么是lambda表达式&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://www.ityoung.xyz/categories/Java/"/>
    
    
    <category term="lambda" scheme="http://www.ityoung.xyz/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot笔记</title>
    <link href="http://www.ityoung.xyz/posts/19457/"/>
    <id>http://www.ityoung.xyz/posts/19457/</id>
    <published>2020-12-31T13:53:40.000Z</published>
    <updated>2020-12-31T14:48:27.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过几天补上"><a href="#过几天补上" class="headerlink" title="过几天补上"></a><code>过几天补上</code></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;过几天补上&quot;&gt;&lt;a href=&quot;#过几天补上&quot; class=&quot;headerlink&quot; title=&quot;过几天补上&quot;&gt;&lt;/a&gt;&lt;code&gt;过几天补上&lt;/code&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://www.ityoung.xyz/categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="http://www.ityoung.xyz/tags/Spring/"/>
    
    <category term="StudyNote" scheme="http://www.ityoung.xyz/tags/StudyNote/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 7.x笔记</title>
    <link href="http://www.ityoung.xyz/posts/51878/"/>
    <id>http://www.ityoung.xyz/posts/51878/</id>
    <published>2020-12-31T13:18:26.000Z</published>
    <updated>2021-02-25T04:47:37.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>此文章是up主-<strong>遇见狂神说</strong>的资料，将他的资料拉取在这是为了更好的查找资料。</p><p>这是大神的讲解视频：<a href="https://www.bilibili.com/video/BV17a4y1x7zq?p=1">https://www.bilibili.com/video/BV17a4y1x7zq?p=1</a></p><p>资料是别人博客拷贝的:<a href="https://awslzhang.top/2020/10/18/%E7%8B%82%E7%A5%9E%E8%AF%B4ElasticSearch-7-x%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%AF%E6%89%8B%E6%95%B2%EF%BC%89/">https://awslzhang.top/2020/10/18/%E7%8B%82%E7%A5%9E%E8%AF%B4ElasticSearch-7-x%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%AF%E6%89%8B%E6%95%B2%EF%BC%89/</a></p><h1 id="狂神聊ElasticSearch-初级阶段"><a href="#狂神聊ElasticSearch-初级阶段" class="headerlink" title="狂神聊ElasticSearch(初级阶段)"></a>狂神聊ElasticSearch(初级阶段)</h1><p>E L K</p><p>版本:Elasticsearch7.6.1 (全网最新的)</p><p>6.X 和 7.X 区别十分大(原生API,RestFul高级)</p><blockquote><p>我们要讲解什么?</p></blockquote><p>SQL: like查询%狂神说%,如果是大数据,就十分慢!索引!</p><p>Elasticsearch:搜索(百度,github,淘宝电商!)</p><ol><li> 聊一个人</li><li> 货比三家</li><li> 安装</li><li> 生态圈</li><li> 分词器 ik</li><li> RestFul操作 ES</li><li> CRUD</li><li> SpringBoot 集成 ElasticSearch(从原理分析!)</li><li> 爬虫爬取数据(京东)</li><li> 实战,模拟全文检索!</li></ol><blockquote><p>以后你只要需要用到搜索,就可以用ES!(大数据量的情况下使用!)</p></blockquote><p>学了这个就不需要用MySQL来查了</p><h1 id="聊聊DougCutting"><a href="#聊聊DougCutting" class="headerlink" title="聊聊DougCutting"></a>聊聊DougCutting</h1><p>为什么要讲这个人,后面要聊大数据</p><blockquote><p>本故事内容来自公众号：新枣课堂</p></blockquote><p>1998年9月4号,google公司在美国硅谷成立.正如大家所知,它是一家<strong>搜索</strong>引擎起家的公司</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610550313.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610550313.png" alt="1596610550313"></a></p><p>无独有偶,一位名叫DougCutting的美国工程师,也迷上了搜索引擎.他做了一个用于文本搜索的函数库(姑且理解为软件的功能组件),命名为Lucene.</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610568104.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610568104.png" alt="1596610568104"></a></p><p>Lucene使用Java写的,目标是为各种中小型应用软件加入全文检索功能.因为好用而且开源(代码公开),非常受程序员们稀罕)</p><p>在这个过程中,google确实找到了不少好的办法,并且无私地分享了出来.</p><p>开源是一种精神!</p><p>2003年,google发表了一篇技术学术论文,公开介绍了自己的谷歌文件系统GFS(google File System).这是google公司为了存储海量搜素数据而设计的专用文件系统</p><p>第二年,2004年,Doug Cutting基于google的GFS论文,实现了分布式文件存储系统,并将它命名为NDFS(Nutch Distributed File System)</p><p>还是2004年,google又发表了一篇技术学术论文,介绍自己的MapReduce编程模型.这个编程模型,用于大规模数据集(大于1TB)的并行分析运算.</p><p>2005年,Doug Cutting 又基于MapReduce,在Nutch搜索引擎实现了该功能.</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610581999.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610581999.png" alt="1596610581999"></a></p><p>2006年,当时依然很厉害的Yahoo(雅虎)公司,招安了Doug Cutting</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610607769.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610607769.png" alt="1596610607769"></a></p><p>截图</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610720399.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610720399.png" alt="1596610720399"></a></p><p>我们继续往下说.</p><p>还是2006年,google有发表论文了</p><p>这次,他们介绍自己的BigTable,这是一种分布式的数据存储系统,一种用来处理海量数据的非关系型数据库.</p><p>Doug Cutting 当然没有放过,在自己的hadoop系统里面,引入了BigTable,并命名为HBase.</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610829469.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610829469.png" alt="1596610829469"></a></p><p>好吧,反正就是紧跟Google时代步伐,你出什么,我学什么</p><p>所有,Hadoop的核心部分,基本上都有Google的影子.</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610891867.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596610891867.png" alt="1596610891867"></a></p><p>2008年1月,Hadoop成功上位,成为Apache基金会的顶级项目.</p><p>同年2月,Yahoo宣布建成了一个拥有1W个内核的Hadoop集群,并将自己的搜索引擎产品部署在上面.</p><p>7月,Hadoop打破世界纪录,成为最快排序1TB数据的系统,用时209秒.</p><h1 id="Elasticsearch概述"><a href="#Elasticsearch概述" class="headerlink" title="Elasticsearch概述"></a>Elasticsearch概述</h1><p>elasticsearch,简称为es,es是一个开源的扩展的分布式全文检索引擎,他可以近乎实时的存储,检索数据;本身扩展性很好,可以扩展到上百台服务器,处理PB级别(大数据时代)的数据.es也使用Java并发使用Lucene作为其核心来实现所有索引和搜索的功能,但是它的目的是通过简单的RESTful API 来隐藏Lucene的复杂性,从而让全文搜索变得简单.</p><p>据国际权威的数据库产品评测机构DB Engines的统计,在2016年1月,ElasticSearch已超过Solr等,成为排名第一的搜索引擎类应用</p><blockquote><p>历史</p></blockquote><p>多年前,一个叫做shay banon的刚结婚不久的失业开发者,由于妻子要去伦敦学习厨师,他便跟着去了.在他找工作的过程中,为了给妻子构建一个食谱的搜索引擎,他开始构建一个早期版本的Lucene</p><p>直接 基于Lucene工作会比较困难,所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能.他发布了他的第一个开源项目,叫做”compass” 后来Shay找到一份工作,这个工作处在高性能和内存数据网络的分布式环境中,因此高性能的,实时的,分布式的搜索引擎也是理所当然需要的.然后他决定重写Compass库,使其成为一个独立的服务叫做Elasticsearch.第一个公开版本出现在2010年2月,在那之后Elasticsearch已经成为Github上最受欢迎的项目之一,代码贡献者超过300人.一家主营Elasticsearch的公司就此成立,他们一边提供商业支持,一边开发新功能,不过Elasticsearch将永远开源且对所有人可用 Shay的妻子依然等待着他的食谱搜索…….</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/03-elasticsearch-%E6%A6%82%E8%BF%B0.assets/1597974189393.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/03-elasticsearch-%E6%A6%82%E8%BF%B0.assets/1597974189393.png" alt="1597974189393"></a></p><p>谁在使用</p><ol><li> 维基百科(百度百科,全文高亮,排序搜素推荐,权重,百度!)</li><li> The Guardian</li><li> Stack Overflow(国外的程序异常处理网站)IT 问题,程序的报错,提交上去,有人会跟你讨论和回答</li><li> Github</li><li> 电商网站 淘宝京东</li><li> 日志数据分析,logstash采集日志,ES进行复杂的数据分析,ELK技术,elasticsearch+logstach+kibana</li><li> 商品价格监控网站,用户设定</li></ol><h1 id="Elasticsearch和Solr差别"><a href="#Elasticsearch和Solr差别" class="headerlink" title="Elasticsearch和Solr差别"></a>Elasticsearch和Solr差别</h1><p>Elasticsearch是一个实时分布式搜索和分析引擎.它让你以前所未有的速度处理大数据成为可能. 维基百科使用它提供全文搜索并高亮关键字,以及输入实时搜索</p><p>Solr简介 Solr是Apache下的一个顶级开源项目,采用Java开发,它是基于Lucene的全文搜索服务器.solr提供了比Lucene更为丰富的查询语言,同时实现了可配置,可扩展,并对索引,搜索性能进行优化 他可以独立运行,运行在tomcat ,jety等这些Servlet容器中 solr对外提供类似于Web-server的API接口</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613190316.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613190316.png" alt="1596613190316"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613206055.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613206055.png" alt="1596613206055"></a></p><p>随着数据量的增加,solr的搜索</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613233807.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613233807.png" alt="1596613233807"></a></p><p>50倍的效率</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613255957.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596613255957.png" alt="1596613255957"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png" alt="1597974203192"></a></p><h2 id="ElasticSearch-vs-Solr-总结"><a href="#ElasticSearch-vs-Solr-总结" class="headerlink" title="ElasticSearch vs Solr 总结"></a>ElasticSearch vs Solr 总结</h2><ol><li> es基本是<code>开箱即用</code>(解压就可以用了!),非常简单.solr安装略微复杂一丢丢!</li><li> Solr利用Zookeeper进行分布式管理,而<code>Elasticsearch自身带有分布式协调管理功能</code>.</li><li> solr支持更多格式的数据,比如JSON,XML,CSV, 而elasticsearch仅仅支持json文件格式</li><li> Solr官网提供的功能很多,而elasticsearch本身更注重核心功能,高级功能多有第三方插件提供,例如图形化界面需要kibana友好质层支撑</li><li>Solr查询块,但更新索引时慢(即插入删除慢),用于电商等查询多的应用;<ul><li>  ES建立索引块(即查询慢),即<code>实时性查询快</code>,用于facebook新浪等搜索.</li><li>  Solr是传统搜索应用的有力解决方案,但Elasticsearch更适用于新兴的实时搜索应用.</li></ul></li><li> Solr比较成熟,有一个更大,更成熟的用户,开发好贡献者社区,而Elasticsearch相对开发维护者较少,更新太快,<code>学习使用成本较高</code>.</li></ol><h1 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h1><blockquote><p>声明:JDK1.8, 最低要求 , Elasticsearch客户端,界面工具!</p></blockquote><p><strong>Java开发,elasticsearch的版本和我们之后对应的Java的核心jar包! 版本对应! JDK环境是正常的</strong></p><p><strong>这里一定要保证</strong></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614089583.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614089583.png" alt="1596614089583"></a></p><p>下载</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614104028.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614104028.png" alt="1596614104028"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614119890.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596614119890.png" alt="1596614119890"></a></p><p>一定要在服务器上面搭建</p><p>下载地址:<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>官网下载巨慢,翻墙,网盘中下载即可</p><p>华为云: <a href="https://mirrors.huaweicloud.com/elasticsearch/7.6.2/">https://mirrors.huaweicloud.com/elasticsearch/7.6.2/</a></p><p>我们学习的话Window和Linux都可以学习 <code>我们这里现在window下学习</code></p><p>ELK三剑客,解压即用!(web项目! 前端环境! npm 下载依赖)</p><p>Node.js python2</p><blockquote><p>window下安装!</p></blockquote><ol><li> elasticSearch</li><li> elasticSearch Head：一个前端项目</li><li> kibana</li></ol><p>过程：略</p><h1 id="ES核心概念理解"><a href="#ES核心概念理解" class="headerlink" title="ES核心概念理解"></a>ES核心概念理解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在前面的学习中,我们掌握了es是什么,同时也把es的服务已经安装启动,那么es是如何去存储数据,数据结构是什么,又是如何实现搜索的呢?我们先来聊聊Elasticsearch的相关概念吧!</p><p><strong>集群,节点,索引,类型,文档,分片,映射</strong>是什么</p><blockquote><p>elasticsearch是面向文档的,关系行数据库和elasticsearch客观的对比! 一切都是json</p></blockquote><table><thead><tr><th>RelationalDB</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>数据库(database)</td><td>索引(indices)</td></tr><tr><td>表(tables)</td><td>types(7版本以及之后会被抛弃，默认_doc)</td></tr><tr><td>行(rows)</td><td>documents</td></tr><tr><td>字段(columns)</td><td>fields</td></tr></tbody></table><p>面向文档 面向文档 面向文档 ~~~</p><p>elasticsearch(集群)中可以包含多个索引(数据库),每个索引中可以包含多个类型(表),每个类型先又包含多个文档(行),每个文档中又包含多个字段(列).</p><h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><p>elasticsearch在后台吧每个<strong>索引划分成多个分片</strong>,每个分片可以在集群中的不同服务器间迁移</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596629957996.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596629957996.png" alt="1596629957996"></a></p><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>一个索引类型中,包含多个文档,比如所文档1,文档2.当我们索引一篇文章时,可以通过这样的一各顺序找到它:索引&gt;类型</p><p><code>&gt;</code>文档id,通过这个组合我们就能索引到某个具体的文档. 注意: id不必是整数,实际上他是一个字符串.</p><table><thead><tr><th>User</th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>1</td><td>zhansan</td><td>18</td></tr><tr><td>2</td><td>kuangshen</td><td>23</td></tr><tr><td>3</td><td></td><td></td></tr></tbody></table><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png" alt="1597974203192"></a></p><p>之前说elasticsearch是面向文档的,name就也为这索引和搜索数据的最小单位是文档,elasticsearch中,文档有几个重要属性:</p><ul><li><p>自我包含,一篇文档同时包含字段和对应值,也就是同时包含key:value!</p></li><li><p>可以是层次型的,一个文档中包含文档,复杂的逻辑实体就是这么来的!</p></li><li><p>灵活的结构,文档不依赖预先定义的模式,我们知道关系型数据库中,要提前定义字段才能使用,在elasticsearch中,对于字段是非常灵活的,有时候,我们可以忽略该字段,或者动态的添加一个新的字段.</p><p>尽管我们可以随意的新增或者忽略某个字段,但是,每个字段的类型非常重要,比如一个年龄字段类型,可以是字符串也可以是整型.因为elasticsearch会保存字段和类型之间的映射及其他的设置.这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中,类型有时候也称为映射类型.</p></li></ul><blockquote><p>类型</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596630612189.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596630612189.png" alt="1596630612189"></a></p><p>类型是文档的逻辑容器,就像关系型数据库一样,表格是行的容器.类型中对于字段的定义称为映射,比如name映射为字符串类型.我们说文档是无模式的,他们不需要拥有映射中所定义的所有字段,比如新增一个字段,那么elasticsearch是怎么做的呢?</p><p>elasticsearch会自动的将新的字段加入映射,但是这个字段的不确定它是什么类型,elasticsearch就开始猜,如果这个值是18,那么elasticsearch会认为他是整型.但是elasticsearch也可能猜不对,所有最安全的方式就是提前定义好所需要的映射,这点跟关系型数据库殊途同归了,先定义好字段,然后在使用,别整什么幺蛾子.</p><blockquote><p>索引</p></blockquote><p><strong>就是数据库</strong></p><p>索引是映射类型的容器,elasticsearch中的索引是一个非常大的文档集合.索引存储了映射类型字段和其他设置,然后他们呗存储到了各个分片上了.我们来研究下分片是如何工作的.</p><h3 id="物理设计-节点和分片-如何工作"><a href="#物理设计-节点和分片-如何工作" class="headerlink" title="物理设计: 节点和分片 如何工作"></a>物理设计: 节点和分片 如何工作</h3><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596630840364.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596630840364.png" alt="1596630840364"></a></p><p>一个集群至少要有一个节点,儿一个节点就是一个elasticsearch进程,节点可以有多个索引默认的,如果你创建索引,那么索引将会有5个分片(primary shard,又称主分片) 构成的,每个主分片会有一个副本(replica shard,又称复制分片)</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596630793639.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596630793639.png" alt="1596630793639"></a></p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596630870602.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596630870602.png" alt="1596630870602"></a></p><blockquote><p>倒排索引</p></blockquote><p>elasticsearch使用的是一种称为倒排索引的结构,采用Lucene倒排索引作为底层.这种结构适用于快速的全文搜索,一个索引由文档中所有不重复的列表构成,对于每一个词,都有一个包含它的文档列表.例如,现在有两个文档,每个文档包含如下内容.</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596631073200.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/07-elasticsearch-es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.assets/1596631073200.png" alt="1596631073200"></a></p><p>为了创建倒排索引,我们首先要将每个文档拆分成独立的词(或称为词条或者tokens),然后创建一个包含所有不重复的词条的排序列表,然后列出每个词条出现在哪个文档:</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596631181270.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596631181270.png" alt="1596631181270"></a></p><p>两个文档都匹配,但是第一个文档比第二个匹配程度更高.如果没有别的条件,现在,这两个包含关键字的文档都将返回.</p><p>再来看一个示例,比如我们通过博客标签来搜索博客文章.那么倒排索引列表就是这样的一个结构:</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596631425757.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596631425757.png" alt="1596631425757"></a></p><p>如果要搜索含有python标签的文章,那相对查找所有原始数据而言,查找倒排索引后的数据将会快的多.只需要查看标签这一栏,然后获取相关文章id即可.</p><h1 id="IK分词器插件"><a href="#IK分词器插件" class="headerlink" title="IK分词器插件"></a>IK分词器插件</h1><h2 id="什么是分词器"><a href="#什么是分词器" class="headerlink" title="什么是分词器"></a><strong>什么是分词器</strong></h2><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596637415868.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596637415868.png" alt="1596637415868"></a></p><p><code>如果使用中文,建议使用ik分词器</code></p><p>IK体用了两个分词算法:<code>ik_smart</code>和,其中ik_smart为最少(ˉ▽￣～) 切~~分,<code>ik_max_word</code>为最细粒度划分! 一会我们测试</p><blockquote><p>安装</p></blockquote><ol><li><p><a href="https://github.com/medcl/elasticsearch-analysis-ik%EF%BC%8C%E7%89%88%E6%9C%AC%E9%9C%80%E8%A6%81%E5%92%8CElasticSearch%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94">https://github.com/medcl/elasticsearch-analysis-ik，版本需要和ElasticSearch版本对应</a></p></li><li><p>下载完毕之后,放入到我们的elasticsearch插件即可</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/08-elasticsearch-IK%E5%88%86%E8%AF%8D%E5%99%A8%E6%8F%92%E4%BB%B6.assets/1596637767841.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/08-elasticsearch-IK%E5%88%86%E8%AF%8D%E5%99%A8%E6%8F%92%E4%BB%B6.assets/1596637767841.png" alt="1596637767841"></a></p><ol><li><p>重启观察ES</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674648793.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674648793.png" alt="1596674648793"></a></p></li><li><p>elasticsearch-plugin 可以通过这个命令来查看加载的插件</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674703775.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674703775.png" alt="1596674703775"></a></p></li><li><p>使用kibana测试!</p><p>查看不同的分词器效果</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674979545.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596674979545.png" alt="1596674979545"></a></p></li></ol></li></ol><h2 id="ik分词器增加我们自己的配置"><a href="#ik分词器增加我们自己的配置" class="headerlink" title="ik分词器增加我们自己的配置"></a>ik分词器增加我们自己的配置</h2><p>这种自己需要的词,需要自己加到我们的分词器字典中!</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675349989.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675349989.png" alt="1596675349989"></a></p><p>重启ES,看细节</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675426305.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675426305.png" alt="1596675426305"></a></p><p>再次测试一下狂神说,</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675486318.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1596675486318.png" alt="1596675486318"></a></p><p>以后的话我们需要自己配置自己的词,只需要在自定义的dic文件中进行配置即可!</p><h1 id="Rest风格说明"><a href="#Rest风格说明" class="headerlink" title="Rest风格说明"></a>Rest风格说明</h1><p>一种软件架构风格,而不是标准,只是提供了一组设计原则和约束条件.它主要用于客户端和服务器交互类的软件.基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存等机制.</p><p>基本Rest风格命令说明</p><table><thead><tr><th>method</th><th>url地址</th><th>描述</th></tr></thead><tbody><tr><td>PUT</td><td>127.0.01:9200/索引名称/_create/文档id</td><td>创建文档（指定id）</td></tr><tr><td>POST</td><td>127.0.01:9200/索引名称/_doc</td><td>创建文档</td></tr><tr><td>POST</td><td>127.0.01:9200/索引名称/_update/文档id</td><td>修改文档</td></tr><tr><td>DELETE</td><td>127.0.01:9200/索引名称</td><td>删除索引</td></tr><tr><td>DELETE</td><td>127.0.01:9200/索引名称/_doc/文档id</td><td>删除文档</td></tr></tbody></table><blockquote><p>基础测试</p></blockquote><h2 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h2><h3 id="索引indices"><a href="#索引indices" class="headerlink" title="索引indices"></a>索引indices</h3><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018173524585.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018173524585.png" alt="image-20201018173524585"></a></p><h3 id="映射mapping"><a href="#映射mapping" class="headerlink" title="映射mapping"></a>映射mapping</h3><p>那么name这个字段用不用指定类型呢,毕竟我们关系型数据库 是需要指定类型映射的啊</p><p><a href="http://victorfengming.gitee.io/course/elasticsearch/base/09-elasticsearch-Rest%E9%A3%8E%E6%A0%BC.assets/1596676128844.png"><img src="http://victorfengming.gitee.io/course/elasticsearch/base/09-elasticsearch-Rest%E9%A3%8E%E6%A0%BC.assets/1596676128844.png" alt="1596676128844"></a></p><ol><li><p>指定字段的类型</p><p>获得这个规则! 可通过GET请求获取具体的信息</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018174140347.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018174140347.png" alt="image-20201018174140347"></a></p></li><li><p>不给索引设置mapping的话，ElasticSearch会默认匹配；如果自己的文档字段没有指定,那么ES就会给我们配置字段类型</p></li></ol><h1 id="关于文档的基本操作"><a href="#关于文档的基本操作" class="headerlink" title="关于文档的基本操作"></a>关于文档的基本操作</h1><p><a href="https://www.bilibili.com/video/BV17a4y1x7zq?p=10">https://www.bilibili.com/video/BV17a4y1x7zq?p=10</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h2><ol><li><p>添加数据</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018173524585.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018173524585.png" alt="image-20201018173524585"></a></p></li><li><p>获取数据</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891281730.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891281730.png" alt="1597891281730"></a></p></li><li><p>更新数据 PUT，更新时是覆盖更新，没有更新的字段会被覆盖为空！</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891378076.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891378076.png" alt="1597891378076"></a></p></li><li><p>Post _update,<code>推荐使用这种更新方式!</code></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891620183.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597891620183.png" alt="1597891620183"></a></p></li></ol><h2 id="简单地搜索"><a href="#简单地搜索" class="headerlink" title="简单地搜索!"></a>简单地搜索!</h2><p><code>GET test/_doc/2</code></p><p>简单的条件查询,可以根据默认的映射规则,产生基本的查询</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018175222885.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018175222885.png" alt="image-20201018175222885"></a> <a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892169142.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892169142.png" alt="1597892169142"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597974203192.png" alt="1597974203192"></a></p><h2 id="复杂操作搜索"><a href="#复杂操作搜索" class="headerlink" title="复杂操作搜索"></a>复杂操作搜索</h2><blockquote><p>select(排序,分页,高亮,模糊查询,精准查询! )</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892352276.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892352276.png" alt="1597892352276"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892367286.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892367286.png" alt="1597892367286"></a></p><p>输出结果不想要那么多,<code>select *</code></p><p>现在是<code>select name,age</code></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892385326.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892385326.png" alt="1597892385326"></a></p><p>可以指定字段</p><p>结果的过滤</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892451582.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892451582.png" alt="1597892451582"></a></p><p>我们之后使用Java操作ES,所有的方法和对象就是这里面的key!</p><blockquote><p>排序</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892561417.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892561417.png" alt="1597892561417"></a></p><blockquote><p>分页查询</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892615017.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892615017.png" alt="1597892615017"></a></p><p>数据下标还是从0开始,和之前所学的数据结构都是一样的!</p><blockquote><p>布尔值查询</p></blockquote><p>must(and) ,所有条件都要符合 where id=1 and name=xxx</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892730673.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892730673.png" alt="1597892730673"></a></p><p>should (or) ,所有条件都要符合 where id=1 or name = xxx</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892885428.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892885428.png" alt="1597892885428"></a></p><p>must not (not)</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892928930.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892928930.png" alt="1597892928930"></a></p><p>过滤器 filter</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892996458.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597892996458.png" alt="1597892996458"></a></p><ul><li>  gt 大于</li><li>  gte 大于等于</li><li>  lt 小于</li><li>  lte 小于等于</li></ul><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893039013.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893039013.png" alt="1597893039013"></a></p><p>匹配多个条件</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893096034.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893096034.png" alt="1597893096034"></a></p><p>用空格分隔也行</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893131147.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893131147.png" alt="1597893131147"></a></p><blockquote><p>精确查询</p></blockquote><p>term 查询时直接通过倒排索引指定的词条进程精确查找的!</p><p>关于分词:</p><p>term,直接查询精确的</p><p>match,会使用分词器解析! (先分析分档,然后再通过分析的分档进行查询! )</p><p><strong>两个类型 text keyword</strong></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893556500.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893556500.png" alt="1597893556500"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893572562.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893572562.png" alt="1597893572562"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893648565.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597893648565.png" alt="1597893648565"></a></p><blockquote><p>多个值匹配精确查询</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597900914957.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597900914957.png" alt="1597900914957"></a></p><blockquote><p>高亮查询!</p></blockquote><p>搜索的高亮条件,会在HTML里面自动的加上标签</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597901143555.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597901143555.png" alt="1597901143555"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597905816361.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597905816361.png" alt="1597905816361"></a></p><h1 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h1><blockquote><p>找文档!</p></blockquote><p><del><a href="https://proxies.app.aidoru.net/-----https://www.elastic.co/guide/index.html">https://proxies.app.aidoru.net/—–https://www.elastic.co/guide/index.html</a></del> <code>失效</code></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906806327.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906806327.png" alt="1597906806327"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906105998.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906105998.png" alt="1597906105998"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906924635.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597906924635.png" alt="img"></a></p><ol><li><p>找到原生的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>找对象</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907115554.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907115554.png" alt="1597907115554"></a></p></li><li><p>分析这个类中的方法即可</p><blockquote><p>配置基本的项目</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907258818.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907258818.png" alt="1597907258818"></a></p><blockquote><p>问题:一定要保证我们导入的依赖和我们的ES版本一致</p></blockquote><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907493787.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907493787.png" alt="1597907493787"></a></p></li></ol><p>按照官网的操作我们要构建一个对象</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907737591.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597907737591.png" alt="1597907737591"></a></p><p>分析源码</p><p>狂神的Spring步骤:</p><ol><li><p>找对象</p></li><li><p>放到spring中待用</p></li><li><p>如果是springboot,那就先分析源码</p><p>xxxAutoConfiguration,xxxProperties</p></li></ol><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597908504743.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/1597908504743.png" alt="1597908504743"></a></p><p>源码中提供的对象</p><p>虽然这里导入了3个类,静态内部类,核心类就一个</p><h2 id="关于索引的API操作详解"><a href="#关于索引的API操作详解" class="headerlink" title="关于索引的API操作详解"></a>关于索引的API操作详解</h2><blockquote><p>具体的Api测试!</p></blockquote><p><code>restHighLevelClient.indices().xxx()</code></p><ol><li><p>创建索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index create</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 构建索引请求实体类 就是创建索引时的&#123;&#125;</span></span><br><span class="line">    CreateIndexRequest springboot_index = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;springboot_index&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2.执行创建索引请求,返回响应</span></span><br><span class="line">    CreateIndexResponse createIndexResponse =</span><br><span class="line">            restHighLevelClient.indices().create(springboot_index, RequestOptions.DEFAULT);</span><br><span class="line">   </span><br><span class="line">    System.out.println(createIndexResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断索引是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">getIndices</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">// 1. 创建请求体内容对象</span></span><br><span class="line">     GetIndexRequest srpingboot_index = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;springboot_index&quot;</span>);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 2. action</span></span><br><span class="line">     <span class="keyword">boolean</span> exists = restHighLevelClient.indices().exists(srpingboot_index,</span><br><span class="line">             RequestOptions.DEFAULT);</span><br><span class="line">     System.out.println(exists);</span><br><span class="line">     GetIndexResponse getIndexResponse = restHighLevelClient.indices().get(srpingboot_index,</span><br><span class="line">             RequestOptions.DEFAULT);</span><br><span class="line">     System.out.println(getIndexResponse);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteIndices</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建请求体内容对象,删除时索引需存在！</span></span><br><span class="line">    DeleteIndexRequest springboot_index = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;springboot_index&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. action</span></span><br><span class="line">    AcknowledgedResponse delete = restHighLevelClient.indices().delete(springboot_index,</span><br><span class="line">            RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="关于文档的API操作详解"><a href="#关于文档的API操作详解" class="headerlink" title="关于文档的API操作详解"></a>关于文档的API操作详解</h2><blockquote><p>创建文档</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// put /index/_create/id &#123;...&#125;</span></span><br><span class="line">    <span class="comment">// 1. 构建创建的文档的内容</span></span><br><span class="line">    IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;springboot_index&quot;</span>);</span><br><span class="line">    indexRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">    indexRequest.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// public IndexRequest source(String source, XContentType xContentType)</span></span><br><span class="line">    indexRequest.source(JSON.toJSONString(<span class="keyword">new</span> User(<span class="string">&quot;zxj&quot;</span>, <span class="number">18</span>)), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 开始请求</span></span><br><span class="line">    IndexResponse index = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(index.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p>这里的返回的全部内容和我们的命令是一样的</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194243887.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194243887.png" alt="image-20201018194243887"></a></p><blockquote><p>更新文档信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// post /index/_update/id &#123;&quot;doc&quot;:&#123;...&#125;&#125;</span></span><br><span class="line">       <span class="comment">// 1. 构建修改的文档的内容,String index, String id</span></span><br><span class="line">       UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;springboot_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">       updateRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">       updateRequest.doc(JSON.toJSONString(<span class="keyword">new</span> User(<span class="string">&quot;new Name&quot;</span>, <span class="number">18</span>)), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2. 开始请求</span></span><br><span class="line">       UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">       System.out.println(updateResponse.status());</span><br><span class="line">       System.out.println(updateResponse.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194653575.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194653575.png" alt="image-20201018194653575"></a></p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194726197.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018194726197.png" alt="image-20201018194726197"></a></p><blockquote><p>删除文档记录</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dropDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// delete /index/_doc/id</span></span><br><span class="line">       <span class="comment">// 1. 构建删除文档的对象,String index, String id</span></span><br><span class="line">       DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;springboot_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">       deleteRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2. 开始请求</span></span><br><span class="line">       DeleteResponse delete = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">       System.out.println(delete.status());</span><br><span class="line">       System.out.println(delete.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018195024638.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018195024638.png" alt="image-20201018195024638"></a></p><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><blockquote><p>特殊的,真的项目一般都会批量插入数据</p></blockquote><p>批量操作bulkRequest有很多类型：例如下述。这里只展示批量增加</p><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018195851648.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201018195851648.png" alt="image-20201018195851648"></a></p><p>批量添加文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulgRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 构建批量请求体</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;springboot_index&quot;</span>);</span><br><span class="line">        indexRequest.source(JSON.toJSONString(<span class="keyword">new</span> User(<span class="string">&quot;zxj&quot;</span>+i, <span class="number">18</span>)), XContentType.JSON);</span><br><span class="line">        bulkRequest.add(indexRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(!bulk.hasFailures());</span><br><span class="line">    System.out.println(bulk.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询搜索🔺"><a href="#查询搜索🔺" class="headerlink" title="查询搜索🔺"></a>查询搜索🔺</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;search/&#123;key&#125;/&#123;page&#125;/&#123;size&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; searchLists(<span class="meta">@PathVariable(&quot;key&quot;)</span> String keyword,</span><br><span class="line">                                             <span class="meta">@PathVariable(&quot;page&quot;)</span> Long page, <span class="meta">@PathVariable(</span></span><br><span class="line"><span class="meta">                                                     &quot;size&quot;)</span> Long size) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 构建搜索对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd1&quot;</span>);</span><br><span class="line">    <span class="comment">// 搜索条件构造</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">2L</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配查询</span></span><br><span class="line">    MatchQueryBuilder title = QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">    searchSourceBuilder.query(title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page</span></span><br><span class="line">    <span class="keyword">if</span> (page&lt;=<span class="number">1L</span>)&#123;</span><br><span class="line">        page = <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    searchSourceBuilder.from((<span class="keyword">int</span>) (page * size));</span><br><span class="line">    searchSourceBuilder.size(Math.toIntExact(size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// highlight</span></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;title&quot;</span>); <span class="comment">// title字段高亮</span></span><br><span class="line">    highlightBuilder.requireFieldMatch(<span class="keyword">false</span>); <span class="comment">// 关键字高亮一次</span></span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);</span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">    searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Map&lt;String, Object&gt;&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">        <span class="comment">// 查询结果</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将高亮的字段覆盖查询结果的该字段</span></span><br><span class="line">        HighlightField highlightField = hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (highlightField != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Text[] fragments = highlightField.fragments();</span><br><span class="line">            StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (Text fragment : fragments) &#123;</span><br><span class="line">                s.append(fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            sourceAsMap.put(<span class="string">&quot;title&quot;</span>, s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        objects.add(sourceAsMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201020213945227.png"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/image-20201020213945227.png" alt="image-20201020213945227"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h1&gt;&lt;p&gt;此文章是up主-&lt;strong&gt;遇见狂神说&lt;/strong&gt;的资料，将他的资料拉取在这是为了更好的查找资料。&lt;/p&gt;
&lt;p&gt;这是大神的讲解视</summary>
      
    
    
    
    <category term="ElasticSearch" scheme="http://www.ityoung.xyz/categories/ElasticSearch/"/>
    
    
    <category term="StudyNote" scheme="http://www.ityoung.xyz/tags/StudyNote/"/>
    
    <category term="NoSQL" scheme="http://www.ityoung.xyz/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis从零基础到入门</title>
    <link href="http://www.ityoung.xyz/posts/46706/"/>
    <id>http://www.ityoung.xyz/posts/46706/</id>
    <published>2020-12-21T15:32:14.000Z</published>
    <updated>2021-02-25T04:47:57.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><h3 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h3><blockquote><p><strong>1.单机Mysql的年代!</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171537.png" alt="image-20201126162435674"></p><p>90年代,一个基本的网站访问量一般不会太大,单个数据库完全足够!</p><p>那个时候,更多的失去使用静态网页 Html~ 服务器根本没有太大的压力!</p><p>思考一下,这种情况下:整个网站的瓶颈是什么?</p><ol><li>数据量如果太大,一个机器根本放不了</li><li>数据的索引(B+ Tree),一个机器内存也放不下</li><li>访问量(读写混合),一个服务器承受不了!</li></ol><blockquote><p><strong>2.Memcached(缓存)+Mysql+垂直拆分(读写分离)</strong></p></blockquote><p>网站80%的情况都是在读,每次都要查询数据库的话就十分的麻烦!所以我们希望减轻数据库的压力,我们可以使用缓存来保证效率</p><p>发展过程: 优化数据结构和索引—&gt;文件缓存(IO)—&gt;Memcached(当时最热门的技术)</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171550.png" alt="image-20201126163132879"></p><blockquote><p><strong>3.分库分表+水平拆分+Mysql集群</strong></p></blockquote><p><strong>技术和业务在发展的同时,对人的要求也越来越高</strong></p><p><code>本质:数据库(读,写)</code></p><p>早些年MyISAM: 表锁,十分影响效率! 高并发下就会出现严重的锁问题</p><p>早些年Innodb: 行锁</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171635.png" alt="image-20201126164233511"></p><blockquote><p><strong>4</strong>.<strong>当今年代</strong></p></blockquote><p>Mysql等关系型数据库就不够用了! 数据量很多,变化很快</p><p>Mysql有的使用它来存储一些比较大的文件,博客,图片!数据库表很大,效率就低了!如果有一种数据库专门处理这种数据,Mysql压力就变得十分小</p><blockquote><p><strong>目前一个基本的互联网项目</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171710.png" alt="image-20201126165917816"></p><p><strong>每一个功能都是用单独的服务器</strong></p><blockquote><p><strong>为什么要用NoSQL!</strong></p></blockquote><p>用户的个人信息,社交网络,地理位置.用户自己产生的数据,用户日志等等爆发式增长.</p><p>这个时候我们就需要使用NoSQL数据库,NoSQL可以很好地解决这些问题</p><h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><blockquote><p><strong>NoSQL</strong></p></blockquote><p>NoSQL = Not Only Sql (不仅仅是SQL)</p><p>关系型数据库: 表格,行,列</p><p>泛指非关系型数据库的,随着web2.0互联网的诞生! 传统的关系型数据库很难应对web2.0时代!尤其是超大规模的高并发的社区!暴露出来很多难以克服的问题,NoSQL在当今大数据环境下的发展十分的迅速,Redis是最快的一个,而且也是当下时代必须要掌握的一项技术!</p><blockquote><p><strong>NoSQL的特点</strong></p></blockquote><p>1.方便扩展(数据之间没有关系,很好扩展)</p><p>2.大数据量高性能(Redis一秒写8万次 ,读取11万次,NoSQL的缓存,是一种细粒度的缓存,性能会比较高)</p><p>3.数据类型是多样型的!(不需要事先设计数据库!随取随用!如果数据量十分大的表,很多人都无法设计)</p><p>4.传统的RDBMS和NoSQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">-结构化组织</span><br><span class="line">-数据和关系都存在单独的表中</span><br><span class="line">-操作操作数据定义语言</span><br><span class="line">-严格的一致性</span><br><span class="line">-基础的事务</span><br><span class="line">-....</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">-不仅仅是数据</span><br><span class="line">-没有固定的查询语言</span><br><span class="line">-键值对存储,列存储,文档存储,图形数据库(社交关系)</span><br><span class="line">-最终一致性</span><br><span class="line">-CAP定理 和 BASE定理(异地多活!)</span><br><span class="line">-三高问题 高性能,高可用,高可扩</span><br><span class="line">-...</span><br></pre></td></tr></table></figure><blockquote><p><strong>了解3V和3高</strong></p></blockquote><p>大数据时代的3V:主要是描述问题的:</p><ol><li>海量的Volume</li><li>多样的Variety</li><li>实时的Velocity</li></ol><p>大数据时代的3高:主要是对程序的要求</p><ol><li>高并发</li><li>高可拓 (随时水平拆分,极其不够了,可以扩展)</li><li>高性能</li></ol><h3 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h3><hr><h4 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对:"></a>KV键值对:</h4><ul><li>新浪:Redis</li><li>美团:Redis+Tair</li><li>阿里,百度:Redis+memcache</li></ul><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><ul><li>MongoDB(一般必须要掌握)<ul><li>MongDB是一个基于分布式文件存储的数据库,C++编写,主要用于处理大量的文档</li><li>MongoDB是一个结语关系型数据库和非关系数据库中间的产品!MongoDB是非关系数据库种功能最丰富的,最像关系型数据库的!</li></ul></li><li>CouchDB</li></ul><h4 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h4><ul><li>HBase</li><li>分布式文件系统</li></ul><h4 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a>图关系数据库</h4><ul><li>他不是存图像,放得是一写关系,比如:朋友圈社交网络</li><li>Neo4j,InfoGrid</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231193141.png" alt="image-20201231193141004"></p><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Redis是什么?</p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务!</p><p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API!</p><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步.</p><p>免费和开源!是当下最热门的NoSQL技术之一!也被人们称为结构化数据库</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171800.png" alt="image-20201126234119042"></p><blockquote><p><strong>Redis能干嘛?</strong></p></blockquote><ol><li>内存存储,持久化,内存中是断电即失,所以说持久化很重要(rdb,aof)</li><li>效率高,可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器,计数器(浏览量)</li><li>……</li></ol><blockquote><p><strong>特性</strong></p></blockquote><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ol><blockquote><p>学习中需要的东西</p></blockquote><ul><li>Redis官网<a href="http://www.redis.io/">www.redis.io</a></li><li><a href="http://www.redis.cn/">redis中文官方网站</a></li></ul><p>注意windows版需要在github上下载(停更好久了!)</p><p><code>Redis推荐都是在Linux服务商搭建的,我们是基于Linux学习!</code></p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ol><li>下载安装包<a href="https://github.com/dmajkic/redis/releases">dmajkic/redis: Redis key-value store (Win32 / Win64 port) (github.com)</a></li><li>解压就可以直接使用</li><li>里面有一个服务端 redis-server.exe 一个客户端redis-cli.exe 还有一个测试速度的redis-benchmark.exe</li><li>打开服务端 就可以在客户端使用了</li></ol><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ol><li>下载安装包 </li><li>解压Redis的安装包!程序一般放在/opt中 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar-zxvf redis </span><br></pre></td></tr></table></figure><p>3.安装基本的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">###提示 redis6需要升级gcc</span></span><br><span class="line"><span class="comment">#升级到 5.3及以上版本</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"> </span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"> </span><br><span class="line"><span class="comment">#注意：scl命令启用只是临时的，推出xshell或者重启就会恢复到原来的gcc版本。</span></span><br><span class="line"><span class="comment">#如果要长期生效的话，执行如下：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在make测试一下</span><br><span class="line"></span><br><span class="line">最后make install 一下</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171808.png" alt="image-20201127190207979"></p><p>4.redis的默认安装路劲<code>usr/local/bin</code></p><p>5.将redis配合文件复制到 第4步的路径中 cp /opt/redis-6.0.6/redis.conf jconfig</p><p>6.redis默认不是后台启动的,修改配置文件!</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171814.png" alt="image-20201127191543541"></p><p>7.启动Redis服务!</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171849.png" alt="image-20201127191820757"></p><p>8.通过redis-cli连接测试</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171816.png" alt="image-20201127192108868"></p><p>9.查看redis的进程是否开启 ps -ef|grep redis</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171854.png" alt="image-20201127192308310"></p><p>10.如何关闭redis服务</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171858.png" alt="image-20201127192456057"></p><h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><hr/><p><strong>redis-benchmark</strong>是一个压力测试工具!</p><p>官方自带的性能测试工具</p><hr/><p>redis-benchmark命令参数</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171902.png" alt="image-20201128001251490"></p><p>我们来简单测试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试: 100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure><hr><p>如何查看这些分析呢?</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231171911.png" alt="image-20201128003145063"></p><h3 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>Redis有16个数据库(可以再配置文件中查看)<ul><li>默认使用的是第0个</li></ul></li><li>如何切换数据库<code>select index</code>(数据库编号)</li><li>查看数据库大小<code>DBSIZE</code></li><li>查看数据所有的key<code>keys *</code></li><li>清除当前数据库<code>flushdb</code></li><li>清空所有数据库<code>flushall</code></li><li>判断当前的key是否存在<code>EXISTS</code></li><li>移除当前的key<code>MOVE</code></li><li>设置过期时间 <code>EXPISE</code> s</li><li>查看当前key的剩余时间 <code>ttl</code></li><li>查看当前key的类型<code>type</code></li></ul><h4 id="Redis是单线程的"><a href="#Redis是单线程的" class="headerlink" title="Redis是单线程的!"></a>Redis是单线程的!</h4><p>明白Redis是很快的,官方表示,Redis是基于内存操作的,CPU不是Redis的性能瓶颈,Redis的瓶颈是根据机器的内存和网络的带宽,所以就使用单线程了!</p><h4 id="Redis为什么单线程还这么快"><a href="#Redis为什么单线程还这么快" class="headerlink" title="Redis为什么单线程还这么快?"></a>Redis为什么单线程还这么快?</h4><ol><li>误区1:高性能的服务器一定是多线程的?</li><li>误区2:多线程(CPU上下文会切换!)一定比单线程效率高!</li></ol><p>核心:redis是将所有的数据全部放在内存中,所以单线程去操作失效率最高的,多线程的上下文切换是耗时的操作!!! 对于内存系统来说,如果没有上下文切换是效率最高的!多次的读写在同一个cpu上,在内存情况下,这个就是最佳的方案!</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件</code>。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p><h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><hr><ul><li>如何切换数据库<code>select index</code>(数据库编号)</li><li>查看数据库大小<code>DBSIZE</code></li><li>查看数据所有的key<code>keys *</code></li><li>清除当前数据库<code>flushdb</code></li><li>清空所有数据库<code>flushall</code></li><li>判断当前的key是否存在<code>EXISTS</code></li><li>移除当前的key<code>MOVE</code></li><li>设置过期时间 <code>EXPISE</code> s</li><li>查看当前key的剩余时间 <code>ttl</code></li><li>查看当前key的类型<code>type</code></li></ul><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><hr><ul><li>追加字符串 <code>append</code></li><li>获取字符串长度<code>strlen</code></li><li>自增1 <code>incr</code></li><li>自减1 <code>decr</code></li><li>自增并设置步长 <code>incrby key 步长</code></li><li>自减并设置步长<code>decrby key 步长</code></li><li>获取指定范围的字符串 <code>getrange</code></li><li>替换指定开始的字符串<code>setrange key 开始位置 更改的值</code></li><li>设置key并附加过期时间 <code>setex</code> (set with expise )</li><li>设置key只有在不存在的时候成功<code>setnx</code>(set if not exist)</li><li>批量设置<code>mset</code></li><li>批量获取<code>mget</code></li><li><code>如何设置对象</code><ul><li><code>set user:1 &#123;name:zhangsan,age:3&#125;</code>  设置一个user id为1的对象值为json数组</li><li>巧妙的设计user:{id}:{filed}<ul><li> <code>mset user:1:name zhangsan user:1:age 3</code></li><li> <code>mget user:1:name user:1:age</code></li></ul></li></ul></li><li>先get然后在set <code>getset</code> <ul><li>如果原先不存在则返回nil 在设置输入的值</li><li>如果原先存在则先返回<code>原先的值</code>,并设置新的值</li></ul></li></ul><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>APPEND key value</code></td><td>向指定的key的value后追加字符串</td><td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td></tr><tr><td><code>DECR/INCR key</code></td><td>将指定key的value数值进行+1/-1(仅对于数字)</td><td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td></tr><tr><td><code>INCRBY/DECRBY key n</code></td><td>按指定的步长对数值进行加减</td><td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td></tr><tr><td><code>INCRBYFLOAT key n</code></td><td>为数值加上浮点型数值</td><td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td></tr><tr><td><code>STRLEN key</code></td><td>获取key保存值的字符串长度</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td></tr><tr><td><code>GETRANGE key start end</code></td><td>按起止位置获取字符串（闭区间，起止位置都取）</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td></tr><tr><td><code>SETRANGE key offset value</code></td><td>用指定的value 替换key中 offset开始的值</td><td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td></tr><tr><td><code>GETSET key value</code></td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td><td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td></tr><tr><td><code>SETNX key value</code></td><td>仅当key不存在时进行set</td><td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td></tr><tr><td><code>SETEX key seconds value</code></td><td>set 键值对并设置过期时间</td><td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td></tr><tr><td><code>MSET key1 value1 [key2 value2..]</code></td><td>批量set键值对</td><td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td></tr><tr><td><code>MSETNX key1 value1 [key2 value2..]</code></td><td>批量设置键值对，仅当参数中所有的key都不存在时执行</td><td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td></tr><tr><td><code>MGET key1 [key2..]</code></td><td>批量获取多个key保存的值</td><td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td></tr><tr><td><code>PSETEX key milliseconds value</code></td><td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td><td></td></tr><tr><td><code>getset key value</code></td><td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td><td></td></tr></tbody></table><p>String</p><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><hr><p>基本数据类型,列表!</p><p>在redis里面我们可以把list玩成,栈 队列 阻塞队列</p><p><code>所有的list命令都是L开头的</code></p><ul><li>将一个值或多个值,插入到列表头部<code>LPUSH</code></li><li>将一个值或多个值,插入到列表的尾部<code>RPUSH</code></li><li>将一个值或多个值,从列表头部移除<code>LPOP</code></li><li>将一个值或多个值,从列表尾部移除<code>RPOP</code></li><li>获取list的值<code>LRANGE</code> <code>0~--1表示全部</code></li><li>获取list的某一个值<code>LINDEX</code>  <code>LINDEX key index</code></li><li>返回列表的长度<code>LLEN</code></li><li>在list中移除指定的个数 value值 <code>LREM</code></li><li>截断list<code>LTRIM</code>  </li><li><code>组合命令</code><ul><li>移除列表的最后一个元素,将他移动到新的列表中<code>RPOPLPUSH</code></li></ul></li><li>将列表中指定下标的值替换为另外一个值,更新操作 <code>LSET``如果不存在这个下标的list将报错</code></li><li>判断list是否存在 <code>EXISTS</code></li><li>列表的插入操作<code>LINSERT key before|after 列表中哪一个元素 插入什么元素</code></li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>LPUSH/RPUSH key value1[value2..]</code></td><td>从左边/右边向列表中PUSH值(一个或者多个)。</td></tr><tr><td><code>LRANGE key start end</code></td><td>获取list 起止元素<code>（索引从左往右 递增）</code></td></tr><tr><td><code>LPUSHX/RPUSHX key value</code></td><td>向已存在的列名中push值（一个或者多个）</td></tr><tr><td>`LINSERT key BEFORE</td><td>AFTER pivot value`</td></tr><tr><td><code>LLEN key</code></td><td>查看列表长度</td></tr><tr><td><code>LINDEX key index</code></td><td>通过索引获取列表元素</td></tr><tr><td><code>LSET key index value</code></td><td>通过索引为元素设值</td></tr><tr><td><code>LPOP/RPOP key</code></td><td>从最左边/最右边移除值 并返回</td></tr><tr><td><code>RPOPLPUSH source destination</code></td><td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td></tr><tr><td><code>LTRIM key start end</code></td><td>通过下标截取指定范围内的列表</td></tr><tr><td><code>LREM key count value</code></td><td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td></tr><tr><td><code>BLPOP/BRPOP key1[key2] timout</code></td><td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><code>BRPOPLPUSH source destination timeout</code></td><td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr></tbody></table><blockquote><p>小结</p></blockquote><ol><li>他实际上是一个链表:before Node after, left right都可以插入值</li><li>如果key不存在,则新建链表</li><li>如果key存在,则可以对链表进行操作</li><li>如果移除了所有值,就是空链表,就是代表不存在</li><li>在两边插入或者改动值效率最高,中间元素相对来说效率会低一些!</li></ol><p><code>消息排队 消息队列 (LPUSH RPOP)左进右出 ,栈(LPUSH LPOP)左进左出</code></p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote><p>SET 无序不重复集合</p></blockquote><p> <code>所有命令都是S开头</code></p><ul><li>set集合中添加值 <code>SADD</code></li><li>查看指定set的所有值 <code>SMEMBERS</code></li><li>判断set中是否包含指定值 <code>SISMEMBER key value</code></li><li>获取set集合中的内容个数 <code>SCARD</code></li><li>移除set中的指定元素<code>SREM</code>  SREM myset value</li><li>随机抽出指定个数元素<code>SRANDMEMBER key count</code></li><li>随机删除一些set集合中的元素 <code>SPOP</code></li><li>将一个指定的值,移动到另外一个set集合中<code>SMOVE</code></li><li>两个数据集合<ul><li>差集 <code>SDIFF key1 key2</code> <code>key1中的差集</code></li><li>交集 <code>SINTER</code> <code>共同好友实现</code></li><li>并集 <code>SUNION</code></li></ul></li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>SADD key member1[member2..]</code></td><td>向集合中无序增加一个/多个成员</td></tr><tr><td><code>SCARD key</code></td><td>获取集合的成员数</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合中所有的成员</td></tr><tr><td><code>SISMEMBER key member</code></td><td>查询member元素是否是集合的成员,结果是无序的</td></tr><tr><td><code>SRANDMEMBER key [count]</code></td><td>随机返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SPOP key [count]</code></td><td>随机移除并返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SMOVE source destination member</code></td><td>将source集合的成员member移动到destination集合</td></tr><tr><td><code>SREM key member1[member2..]</code></td><td>移除集合中一个/多个成员</td></tr><tr><td><code>SDIFF key1[key2..]</code></td><td>返回所有集合的差集 key1- key2 - …</td></tr><tr><td><code>SDIFFSTORE destination key1[key2..]</code></td><td>在SDIFF的基础上，将结果保存到集合中<code>(覆盖)</code>。不能保存到其他类型key噢！</td></tr><tr><td><code>SINTER key1 [key2..]</code></td><td>返回所有集合的交集</td></tr><tr><td><code>SINTERSTORE destination key1[key2..]</code></td><td>在SINTER的基础上，存储结果到集合中。覆盖</td></tr><tr><td><code>SUNION key1 [key2..]</code></td><td>返回所有集合的并集</td></tr><tr><td><code>SUNIONSTORE destination key1 [key2..]</code></td><td>在SUNION的基础上，存储结果到及和张。覆盖</td></tr><tr><td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td><td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td></tr></tbody></table><h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><blockquote><p>Map集合,key-map!这个key的值就是一个map集合.</p></blockquote><p><code>所有命令都是H开头的</code></p><ul><li>在hash中设置值 <code>hset </code>  <code>hset myhash field1 jiuyuesheng</code></li><li>在hash中获取值<code>hget</code>  <code>hget myhash field1</code></li><li>在hash中设置多个值 <code>hmset</code> <code> hmset myhash field1 jiuyuesheng field2 lidaben</code></li><li>在hash中获取多个值<code>hmget</code>  hmget myhash field1 field2</li><li>获取hash所有的值<code>hgetall</code> hgetall myhash</li><li>删除hash中指定字段的值 <code>hdel</code> hdel myhash field1</li><li>获取hash中的长度 <code>hlen</code></li><li>获取所有的hash字段 <code>hkeys</code></li><li>获取所有hash值 <code>hvals</code></li><li>自增字段<code>incr incrby </code>   <code>hincrby myhash field3 1</code></li><li>自减字段 <code>decr decrby</code>  <code>hdecrby myhash field3 1</code></li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td></tr><tr><td><code>HMSET key field1 value1 [field2 value2..]</code></td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td><code>HSETNX key field value</code></td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td><code>HEXISTS key field</code></td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td><code>HGET key field value</code></td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td><code>HMGET key field1 [field2..]</code></td><td>获取所有给定字段的值</td></tr><tr><td><code>HGETALL key</code></td><td>获取在哈希表key 的所有字段和值</td></tr><tr><td><code>HKEYS key</code></td><td>获取哈希表key中所有的字段</td></tr><tr><td><code>HLEN key</code></td><td>获取哈希表中字段的数量</td></tr><tr><td><code>HVALS key</code></td><td>获取哈希表中所有值</td></tr><tr><td><code>HDEL key field1 [field2..]</code></td><td>删除哈希表key中一个/多个field字段</td></tr><tr><td><code>HINCRBY key field n</code></td><td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td></tr><tr><td><code>HINCRBYFLOAT key field n</code></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td></tr><tr><td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>迭代哈希表中的键值对。</td></tr></tbody></table><blockquote><p>hash变更的数据 user name age,尤其是用户信息,经常变更信息,<code>hash更适合对象的存储,string更适合字符串存储!</code></p><p>hset user:1 name jiuyuesheng age 18</p></blockquote><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset  (有序集合)"></a>Zset  (有序集合)</h3><blockquote><p>在set的集合上,增加了一个值,</p><p>set k1 v1   zset k1 score1 v1</p><p><code>所有命令以Z开头</code></p></blockquote><ul><li>添加一个值 <code>zadd</code>  zadd myset 1 on</li><li>添加多个值 zadd myset 2 two 3 three</li><li>通过score<strong>从小到大</strong>排序 <code>zrangbyscore</code>   zrangbyscore key -inf +inf withscore(<code>数据带score</code>) </li><li>通过score从大到小排序 <code>zrevrangbyscore</code></li><li>获取指定区间的数量 <code>zcount</code></li><li>其余和SET类型一致</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ZADD key score member1 [score2 member2]</code></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td><code>ZCARD key</code></td><td>获取有序集合的成员数</td></tr><tr><td><code>ZCOUNT key min max</code></td><td>计算在有序集合中指定区间score的成员数</td></tr><tr><td><code>ZINCRBY key n member</code></td><td>有序集合中对指定成员的分数加上增量 n</td></tr><tr><td><code>ZSCORE key member</code></td><td>返回有序集中，成员的分数值</td></tr><tr><td><code>ZRANK key member</code></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><code>ZRANGE key start end</code></td><td>通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td><code>ZRANGEBYLEX key min max</code></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><code>ZRANGEBYSCORE key min max</code></td><td>通过分数返回有序集合指定区间内的成员<code>-inf 和 +inf分别表示最小最大值，只支持开区间()</code></td></tr><tr><td><code>ZLEXCOUNT key min max</code></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><code>ZREM key member1 [member2..]</code></td><td>移除有序集合中一个/多个成员</td></tr><tr><td><code>ZREMRANGEBYLEX key min max</code></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYRANK key start stop</code></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td><code>ZREVRANGE key start end</code></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td><code>ZREVRANGEBYSCORRE key max min</code></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><code>ZREVRANGEBYLEX key max min</code></td><td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td></tr><tr><td><code>ZREVRANK key member</code></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td></tr><tr><td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><p><code>可以使用的案例</code></p><ol><li>带权重的消息 1 普通消息 2重要消息</li><li>排行榜 Top N</li><li>set排序 班级成绩表 员工工资表</li></ol><h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><blockquote><p>朋友的定位,附近的人,打车距离计算  Redis的Geo在Redis3,2就推出了!这个功能可以推算地理位置的信息,两地之间的距离,方圆几里的人</p></blockquote><hr><ul><li><p>添加城市的经纬度<code>geoadd</code>  <code>geoadd china:city 116.40 39.90 beijing(经度 纬度  名称)</code></p><ul><li>两级无法直接添加,我们一般会下载城市数据数据,通过Java程序一次性导入</li></ul></li><li><p>获取一个或多个指定城市的经度纬度 <code>geopos</code> <code>geopos china:city beijing</code></p></li><li><p>计算两地的距离(一个位置错误,则返回nil,可以设置返回的距离单位) <code>geodist</code> <code>geodist china:city beijing shanghai km</code></p></li><li><p>以给定的经纬度为中心,找出某一半径内的元素<code>georadius</code> <code>georadius china:city 自己的经纬度 距离 距离单位 withdist withcoord count num</code></p></li><li><p>找出指定元素周围的其他元素 <code>georadiusbymember``georadiusbymember china:city beijing 5000 km</code></p><blockquote><p>GEO底层的实现原理是Zset!我们可以使用Zset命令来操作geo </p></blockquote></li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote><p>什么是基数? </p></blockquote><p>不重复的元素</p><blockquote><p>简介</p></blockquote><p>Redis Hyperloglog 基数统计的算法!</p><p>优点:占用的内存是固定的,2^64不同的元素的技术.只需要消耗12kb的内存!如果从内存的角度来比较我们首选Hyperloglog.</p><p><strong>网页的UV(一个人访问的一个网站多次,但是还是算作一次)</strong></p><p>Hyperloglog有0.81%的误差率! 统计UV任务,我们可以忽略不计!</p><ul><li>创建第一组元素<code>PFadd``PFadd mykey  元素</code></li><li>合并两组元素<code>PFMERGE</code> <code>PFMERGE mykey1 mykey2</code></li><li>查看一组元素的不重复的数量 <code>PFCOUNT</code>  <code>PFCOUNT mykey1</code></li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><blockquote><p>位存储 <code>一字节=8位</code></p></blockquote><p>统计用户信息:活跃 不活跃;登录 未登录;只有两种状态;</p><p>Bitmap位图,数据结构!都是操作二进制来进行记录, 0  1;</p><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用bitmaps来记录一周的打卡记录</span></span><br><span class="line"><span class="comment">#设置每一天的打卡记录</span></span><br><span class="line">setbit sign 0 0</span><br><span class="line">setbit sign 1 1</span><br><span class="line">setbit sign 2 0</span><br><span class="line">setbit sign 3 1</span><br><span class="line">setbit sign 4 1</span><br><span class="line">setbit sign 5 1</span><br><span class="line">setbit sign 6 0</span><br><span class="line"><span class="comment">#获取某一天是否打卡</span></span><br><span class="line">getbit sign index</span><br><span class="line"><span class="comment">#统计打卡的天数</span></span><br><span class="line">bitcount sign  --&gt; 4</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="Redis事务的概念："><a href="#Redis事务的概念：" class="headerlink" title="Redis事务的概念："></a><strong>Redis事务的概念：</strong></h3><p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p><code>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</code>　　</p><h3 id="Redis事务没有隔离级别的概念："><a href="#Redis事务没有隔离级别的概念：" class="headerlink" title="Redis事务没有隔离级别的概念："></a><strong>Redis事务没有隔离级别的概念：</strong></h3><p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p><h3 id="Redis不保证原子性："><a href="#Redis不保证原子性：" class="headerlink" title="Redis不保证原子性："></a><strong>Redis不保证原子性：</strong></h3><p>　　Redis中，<code>单条命令是原子性执行的，但事务不保证原子性</code>，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis事务的三个阶段："><a href="#Redis事务的三个阶段：" class="headerlink" title="Redis事务的三个阶段："></a><strong>Redis事务的三个阶段：</strong></h3><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><h3 id="Redis事务相关命令："><a href="#Redis事务相关命令：" class="headerlink" title="Redis事务相关命令："></a><strong>Redis事务相关命令：</strong></h3><ul><li>　　<code>watch</code> key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</li><li>　　<code>multi</code> : 标记一个事务块的开始（ queued ）</li><li>　　<code>exec </code>: 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</li><li>　　<code>discard</code> : 取消事务，放弃事务块中的所有命令</li><li>　　<code>unwatch </code>: 取消watch对所有key的监控</li></ul><hr>### 一些事务的案例:解决乐观锁问题  (本质就是执行事务之前比较数据的version)<blockquote><p>正常事务</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172046.png" alt="image-20201130211506607"></p><blockquote><p>放弃事务</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172049.png" alt="image-20201130211525432"></p><blockquote><p>编译型异常(代码有问题!命令有错),事务中所有的命令都不执行</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172053.png" alt="image-20201130211541544"></p><blockquote><p>运行时异常(1/0),如果事务队列存在语法性错误,那么执行命令的时候,其他命令的正常执行,错误命令抛出异常</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172059.png" alt="image-20201130211554822"></p><blockquote><p>解决乐观锁问题</p><ul><li>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172106.png" alt="image-20201130211713678"></p><ul><li>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172115.png" alt="1"></p><p>一但执行 EXEC 开启事务的执行后，无论事务是否执行成功， WARCH 对变量的监控都将被取消。</p><p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p><p> <strong>总结：</strong></p><p>　　watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p></blockquote><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用java来操作Redis</p><blockquote><p>jedis:是Redi官方推荐的java连接开发工具!使用java来操作Redis中间件!如果你要是用java来操作redis,我们则需要对jedis十分熟悉!</p></blockquote><p><code>其中的api接口都是和上面的命令一致</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span> );</span><br><span class="line"></span><br><span class="line">System.out.println(jedis.ping());</span><br></pre></td></tr></table></figure><h1 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h1><p>说明:在springboot2.x之后,原来使用的jedis被替换为了lettuce?</p><p>jedis:采用的是直连,多个线程操作的话,是不安全的,如果想要避免不安全,使用jedis pool连接池.<code>更像BIO模式!</code></p><p>lettuce:采用netty,实例可以在多个线程中进行共享,不存在线程不安全的情况,可以减少线程数据 .<code>更像NIO模式!</code></p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>配置连接</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * RedisTemplate</span></span><br><span class="line"><span class="comment">       * opsForValue 相当于string    操作String类型</span></span><br><span class="line"><span class="comment">       *opsForList   相当于list      操作list类型</span></span><br><span class="line"><span class="comment">       * opsForSet   相当于set       操作set类型</span></span><br><span class="line"><span class="comment">       * opsForHash  相当于Hash      操作Hash类型</span></span><br><span class="line"><span class="comment">       * opsForZset  相当于Zset      操作Zset类型</span></span><br><span class="line"><span class="comment">       * opsForGeo   相当于操作地图的经纬度</span></span><br><span class="line"><span class="comment">       * opsForHyperLogLog    相当于操作基数(不重复的元素)</span></span><br><span class="line"><span class="comment">       * opsForValue.setBit  相当于操作Bitmap</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      redisTemplate.opsForHyperLogLog()</span><br><span class="line">      redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jiuyuesheng&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;listValue&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForList().leftPop(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForSet().pop(<span class="string">&quot;set&quot;</span>));</span><br><span class="line">   </span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;jiuyuesheng&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;lidaben&quot;</span>,<span class="number">3999</span>);</span><br><span class="line">      redisTemplate.opsForZSet().add(<span class="string">&quot;salary&quot;</span>,<span class="string">&quot;tangxuan&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">      Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; salarys = redisTemplate.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;salary&quot;</span>, Double.MIN_VALUE, Double.MAX_VALUE);</span><br><span class="line">      Iterator&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; iterator = salarys.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">          ZSetOperations.TypedTuple&lt;String&gt; typedTuple = iterator.next();</span><br><span class="line">          System.out.println(typedTuple.getValue()+<span class="string">&quot;  &quot;</span>+typedTuple.getScore());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiuyuesheng.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jiuyuesheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/2  19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        <span class="comment">//自定义RedisTemplate</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义jackson序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key使用String的序列化方式</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也是用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//value的key使用jackson的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value也是用jackson的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231172821.png" alt="image-20201231172820900"></p><blockquote><p>可以使用 include 组合多个配置问题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173053.png" alt="image-20201231173053568"></p><blockquote><p>网络配置</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173115.png" alt="image-20201231173114985"></p><blockquote><p>日志输出级别</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173712.png" alt="image-20201231173712401"></p><blockquote><p>日志输出文件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231173736.png" alt="image-20201231173736612"></p><blockquote><p>持久化规则</p></blockquote><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174724.png" alt="image-20201231174724773"></p><blockquote><p>RDB文件相关</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174744.png" alt="image-20201231174743844"></p><p>​    <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231174803.png" alt="image-20201231174803176" style="zoom:150%;" /></p><blockquote><p>主从复制</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181415.png" alt="image-20201231181415279"></p><blockquote><p>Security模块中进行密码设置</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181442.png" alt="image-20201231181442156"></p><blockquote><p>客户端连接相关</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p><p><strong>设置方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br></pre></td></tr></table></figure><h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p><p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p><p><strong>3、volatile-random：</strong>随机删除即将过期key</p><p><strong>4、allkeys-random：</strong>随机删除</p><p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p><p><strong>6、noeviction ：</strong> 永不过期，返回错误</p><blockquote><p>AOF相关部分</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181522.png" alt="image-20201231181522866"></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181544.png" alt="image-20201231181544511"></p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>面试和工作持久化都是重点!</p><p>Redis是内存数据库,如果不将内存中的数据库状态保存在磁盘中,那么一旦服务器进程退出,服务器的数据库状态也会消失.所以Redis提供了持久化功能</p><h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><blockquote><p>什么是RDB</p></blockquote><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231181654.png" alt="RDB"  /><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182416.png" alt="image-20201205194054876" style="zoom: 50%;" /><p>在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,他恢复时是将快照文件直接读入内存里.</p><p>Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入一个临时文件中,待持久化过程结束了,在用这个临时文件替换上次持久化恢复好的文件,整个过程中,主进程是不会进行任何io操作的.这就确保了极高的性能.如果需要进行大规模数据恢复,且对于数据恢复的完整性不是非常敏感,那么RDB方式比AOF方式更加的高效.RDB的缺点是最后一次持久化后的数据可能会丢失.</p><p><code>RDB保存的文件是dump.rdb</code></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h5 id="save"><a href="#save" class="headerlink" title="save"></a>save</h5><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><h5 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h5><p><code>flushall</code> 命令也会触发持久化 ；</p><h5 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h5><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182539.png" alt="image-20201231182539011"></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182615.png" alt="image-20201231182614970"></p><h5 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h5><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182634.png" alt="image-20201231182634077"></p><h5 id="bgsave和save对比"><a href="#bgsave和save对比" class="headerlink" title="bgsave和save对比"></a><strong>bgsave和save对比</strong></h5><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h3 id="AOF-Append-only-File"><a href="#AOF-Append-only-File" class="headerlink" title="AOF(Append only File)"></a>AOF(Append only File)</h3><p>将我们的所有命令都记录下来,history,恢复的时候就把这个文件全部执行一遍</p><blockquote><p>什么是AOF</p></blockquote><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231182641.png" alt="image-20201208005002139" style="zoom:50%;" /><p>以日志的形式来记录每个写操作,将Redis执行过的所有的指令记录下来(读操作不记录),只许追加文件但不可以改写文件,redis启动之初会读取该文件重新构造数据,换言之,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作.</p><p><code>Aof保存的是appendonly.aof文件</code></p><p><del>默认不开启,但是更改配置文件重启redis就可以查看bin下的appendonly.aof文件</del></p><p>如果这个aof文件有错误,这时候redis是启动不了的,这时候我们就需要使用redis给我们提供的一个工具来修复他<code>redis-check-aof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure><blockquote><p>重写规则</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184227.png" alt="image-20201208013112876"></p><p>当文件大于64mb的时候,会fork一个新的进程来重写我们的aof文件</p><blockquote><p><strong>优点和缺点</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认是不开启aof模式的,默认使用的是rdb方式持久化,在大多数情况下rdf是够用的</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment">#持久化的文件名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always   #每次修改都会 sync.</span></span><br><span class="line">appendfsync everysec   <span class="comment">#每秒执行一次 sync.</span></span><br><span class="line"><span class="comment"># appendfsync no       #不执行 sync,这时候操作系统自己同步数据,速度是最快的.</span></span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>每一次修改都同步,文件的完整性会更加好!</li><li>每秒执行一次,可能会丢失一秒的数据</li><li>从不同步,效率最高的.</li></ol><p>缺点:</p><ol><li>相对于数据文件来说,aof远远大于rdb,修复的速度也比rdb慢!</li><li>aof运行效率也要比rdb慢,所以我们redis默认的配置就是rdb持久化.</li></ol><h3 id="RDB-和-AOF-对比选择"><a href="#RDB-和-AOF-对比选择" class="headerlink" title="RDB 和 AOF 对比选择"></a>RDB 和 AOF 对比选择</h3><table><thead><tr><th>RDB</th><th>AOF</th><th></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h1 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184235.png" alt="image-20201210134451752"></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184251.png" alt="image-20201231184251062"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231184313.png" alt="image-20201231184313655"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231185737.png" alt="image-20201231185737002"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li><li>实时消息系统(网站站长给用户发送推荐信息)</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231185754.png" alt="image-20201231185754015"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p><code>默认情况下，每台Redis服务器都是主节点；</code>我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192358.png" alt="image-20201231192358079"></p><p>然后主机上也能看到从机的状态：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192414.png" alt="image-20201231192414189"></p><p>我们这里是使用命令搭建，是暂时的，<code>真实开发中应该在从机的配置文件中进行配置，</code>这样的话是永久的。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192431.png" alt="image-20201231192430924"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p><p>单机单个哨兵</p><p> <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192552.png" alt="image-20201216175931890"></p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>多哨兵模式</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192559.png" alt="image-20201216180033114"></p><p>哨兵的核心配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192648.png" alt="image-20201231192648527"></p><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192715.png" alt="image-20201231192715625"></p><blockquote><p>哨兵模式优缺点</p></blockquote><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><p><strong>缺点：</strong></p><ol><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><p>完整的哨兵模式配置文件 sentinel.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192757.png" alt="image-20201231192757429"></p><p><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192808.png" alt="image-20201231192808689"></p><p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231192821.png" alt="image-20201231192821187"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis笔记&quot;&gt;&lt;a href=&quot;#Redis笔记&quot; class=&quot;headerlink&quot; title=&quot;Redis笔记&quot;&gt;&lt;/a&gt;Redis笔记&lt;/h1&gt;&lt;h1 id=&quot;Nosql概述&quot;&gt;&lt;a href=&quot;#Nosql概述&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Redis" scheme="http://www.ityoung.xyz/categories/Redis/"/>
    
    
    <category term="StudyNote" scheme="http://www.ityoung.xyz/tags/StudyNote/"/>
    
    <category term="NoSQL" scheme="http://www.ityoung.xyz/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基本使用</title>
    <link href="http://www.ityoung.xyz/posts/45960/"/>
    <id>http://www.ityoung.xyz/posts/45960/</id>
    <published>2020-12-21T15:31:18.000Z</published>
    <updated>2021-02-25T04:47:50.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库概述及数据准备"><a href="#数据库概述及数据准备" class="headerlink" title="数据库概述及数据准备"></a>数据库概述及数据准备</h2><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><p>SQL，一般发音为sequel，SQL的全称Structured Query Language)，SQL用来和数据库打交道，完成和数据库的通信，SQL是一套标准。但是每一个数据库都有自己的特性别的数据库没有,当使用这个数据库特性相关的功能,这时SQL语句可能就不是标准了.(90%以上的SQL都是通用的)</p><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>数据库，通常是一个或一组文件，保存了一些符合特定规格的数据,数据库对应的英语单词是DataBase,简称:DB,数据库软件称为数据库管理系统（DBMS），全称为DataBase Management System，如：Oracle、SQL Server、MySql、Sybase、informix、DB2、interbase、PostgreSql 。</p><h3 id="MySql概述"><a href="#MySql概述" class="headerlink" title="MySql概述"></a>MySql概述</h3><p>MySQL最初是由“MySQL AB”公司开发的一套关系型数据库管理系统（RDBMS-Relational Database Mangerment System）。</p><p>MySQL不仅是最流行的开源数据库，而且是业界成长最快的数据库，每天有超过7万次的下载量，其应用范围从大型企业到专有的嵌入应用系统。</p><p>MySQL AB是由两个瑞典人和一个芬兰人：David Axmark、Allan Larsson和Michael “Monty” Widenius在瑞典创办的。</p><p>在2008年初，Sun Microsystems收购了MySQL AB公司。在2009年，Oracle收购了Sun公司，使MySQL并入Oracle的数据库产品线。1.1.表</p><p>表(table)是一种<strong>结构化的文件</strong>，可以用来存储特定类型的数据，如：学生信息，课程信息，都可以放到表中。另外表都有特定的名称，而且不能重复。表中具有几个概念：列、行、主键。 列叫做字段(Column),行叫做表中的记录,每一个字段都有:字段名称/字段数据类型/字段约束/字段长度</p><p>学生信息表</p><table><thead><tr><th>学号（主键）</th><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>00001</td><td>张三</td><td>男</td><td>20</td></tr><tr><td>00002</td><td>李四</td><td>女</td><td>20</td></tr></tbody></table><h3 id="SQL的语句分类"><a href="#SQL的语句分类" class="headerlink" title="SQL的语句分类"></a>SQL的语句分类</h3><p>数据查询语言(DQL-Data Query Language) </p><blockquote><p>代表关键字:select </p></blockquote><p>数据操纵语言(DML-Data Manipulation Language)</p><blockquote><p>代表关键字:insert,delete,update</p></blockquote><p>数据定义语言(DDL-Data Definition Language)</p><blockquote><p>代表关键字:create ,drop,alter,</p></blockquote><p>事务控制语言(TCL-Transactional Control Language)</p><blockquote><p>代表关键字:commit ,rollback;</p></blockquote><p>数据控制语言(DCL-Data Control Language)</p><blockquote><p>代表关键字:grant,revoke.</p></blockquote><h3 id="导入演示数据"><a href="#导入演示数据" class="headerlink" title="导入演示数据"></a>导入演示数据</h3><p>使用MySQL命令行客户端来装载数据库。</p><ol><li><p>连接MySql</p><p>​    <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165032485.png" alt="image-20201218165032485"></p></li><li><p>创建“bjpowernode”数据库</p><p>mysql&gt; create database bjpowernode;</p></li><li><p>选择数据库</p><p>mysql&gt; use bjpowernode</p></li><li><p>导入数据</p><p>mysql&gt;source D:\ bjpowernode.sql</p></li><li><p>删除数据库(这里不要做!)</p><p>mysql&gt; drop database bjpowernode;</p></li></ol><h3 id="表结构描述"><a href="#表结构描述" class="headerlink" title="表结构描述"></a>表结构描述</h3><p>表名称：dept</p><p>描述：部门信息表</p><table><thead><tr><th>英文字段名称</th><th>中文描述</th><th>类型</th></tr></thead><tbody><tr><td>DEPTNO</td><td>部门编号</td><td>INT(2)</td></tr><tr><td>DNAME</td><td>部门名称</td><td>VARCHAR(14)</td></tr><tr><td>LOC</td><td>位置</td><td>VARCHAR(13)</td></tr></tbody></table><p>表名称：emp</p><p>描述：员工信息表</p><table><thead><tr><th>英文字段名称</th><th>中文描述</th><th>类型</th></tr></thead><tbody><tr><td>EMPNO</td><td>员工编号</td><td>INT (4)</td></tr><tr><td>ENAME</td><td>员工姓名</td><td>VARCHAR(10)</td></tr><tr><td>JOB</td><td>工作岗位</td><td>VARCHAR(9)</td></tr><tr><td>MGR</td><td>上级领导</td><td>INT (4)</td></tr><tr><td>HIREDATE</td><td>入职日期</td><td>DATE</td></tr><tr><td>SAL</td><td>薪水</td><td>DOUBLE(7,2)</td></tr><tr><td>COMM</td><td>津贴</td><td>DOUBLE (7,2)</td></tr><tr><td>DEPTNO</td><td>部门编号</td><td>INT(2)</td></tr></tbody></table><p>注：DEPTNO字段是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用</p><p>表名称：salgrade</p><p>描述：薪水等级信息表</p><table><thead><tr><th>英文字段名称</th><th>中文描述</th><th>类型</th></tr></thead><tbody><tr><td>GRADE</td><td>等级</td><td>INT</td></tr><tr><td>LOSAL</td><td>最低薪水</td><td>INT</td></tr><tr><td>HISAL</td><td>最高薪水</td><td>INT</td></tr></tbody></table><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看msyql版本"><a href="#查看msyql版本" class="headerlink" title="查看msyql版本"></a>查看msyql版本</h3><p>MySQL程序选项具有以下两种通用形式：</p><p>–     长选项，由单词之前加两个减号组成</p><p>–     短选项，由单个字母之前加一个减号组成</p><p>C:\Users\Administrator&gt;<code>mysql --version</code></p><p>mysql Ver 14.14 Distrib 5.5.36, for Win32 (x86)</p><p>C:\Users\Administrator&gt;<code>mysql -V</code></p><p>mysql Ver 14.14 Distrib 5.5.36, for Win32 (x86)</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol><li><p>create database 数据库名称;</p><p><code>create database bjpowernode;</code></p></li><li><p>use 数据库名称</p><p><code>use bjpowernode;</code></p></li></ol><p>在数据库中建立表，因此创建表的时候必须要先选择数据库。</p><h3 id="查询当前使用的数据库"><a href="#查询当前使用的数据库" class="headerlink" title="查询当前使用的数据库"></a>查询当前使用的数据库</h3><p>select database();</p><p>查询数据库版本也可以使用</p><p>select  version();</p><h3 id="终止一条语句"><a href="#终止一条语句" class="headerlink" title="终止一条语句"></a>终止一条语句</h3><p>如果想要终止一条正在编写的语句，可键入\c。</p><h3 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a>退出mysql</h3><p>可使用\q、QUIT或EXIT：</p><p>如：mysql&gt; \q (ctrl+c)</p><hr><h2 id="查看“演示数据”的表结构"><a href="#查看“演示数据”的表结构" class="headerlink" title="查看“演示数据”的表结构"></a>查看“演示数据”的表结构</h2><h3 id="查看和指定现有的数据库"><a href="#查看和指定现有的数据库" class="headerlink" title="查看和指定现有的数据库"></a>查看和指定现有的数据库</h3><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165125116.png" alt="image-20201218165125116"></p><h3 id="指定当前缺省数据库"><a href="#指定当前缺省数据库" class="headerlink" title="指定当前缺省数据库"></a>指定当前缺省数据库</h3><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165152303.png" alt="image-20201218165152303"></p><h3 id="查看当前使用的库"><a href="#查看当前使用的库" class="headerlink" title="查看当前使用的库"></a>查看当前使用的库</h3><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165204244.png" alt="image-20201218165204244"></p><h3 id="查看当前库中的表"><a href="#查看当前库中的表" class="headerlink" title="查看当前库中的表"></a>查看当前库中的表</h3><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165216532.png" alt="image-20201218165216532"></p><h3 id="查看其他库中的表"><a href="#查看其他库中的表" class="headerlink" title="查看其他库中的表"></a>查看其他库中的表</h3><p><code>show tables from &lt;database name&gt;;</code></p><p>如查看exam库中的表</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201231163851918.png" alt="image-20201231163851918"></p><h3 id="查看表的结构"><a href="#查看表的结构" class="headerlink" title="查看表的结构"></a>查看表的结构</h3><p><code>desc &lt;table name&gt;;</code></p><p>如：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201218165240022.png" alt="image-20201218165240022"></p><h3 id="查看表的创建语句"><a href="#查看表的创建语句" class="headerlink" title="查看表的创建语句"></a>查看表的创建语句</h3><p><code>show create table &lt;table name&gt;;</code></p><p>如：</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165235.png" alt="image-20201218165249789"> </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165233.png" alt="image-20201218165307791">                    </p><h2 id="简单的查询"><a href="#简单的查询" class="headerlink" title="简单的查询"></a>简单的查询</h2><h3 id="查询一个字段"><a href="#查询一个字段" class="headerlink" title="查询一个字段"></a>查询一个字段</h3><blockquote><p>查询员工姓名</p></blockquote><p><code>select ename from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165230.png" alt="image-20201218165318161"></p><p>Select语句后面跟的是字段名称，select是关键字，select和字段名称之间采用空格隔开，from表示将要查询的表，它和字段之间采用空格隔开</p><h3 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h3><blockquote><p>查询员工的编号和姓名</p></blockquote><p>  <code>select empno, ename from emp;</code></p><p>  <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165226.png" alt="image-20201218165326501">  </p><p>查询多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段不能使用逗号了。</p><h3 id="查询全部字段"><a href="#查询全部字段" class="headerlink" title="查询全部字段"></a>查询全部字段</h3><p>可以将所有的字段放到select语句的后面，这种方案不方便，但是比较清楚，我们可以采用如下便捷的方式查询全部字段</p><p><code> select * from emp; </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165036.png" alt="image-20201218165334984"></p><p>采用<code>select * from emp</code>，虽然简单，但是*号不是很明确，建议查询全部字段将相关字段写到select语句的后面,在以后java连接数据库的时候,是需要在java程序中编写SQL语句的,这个时候编写的SQL语句不建议使用<code>select *</code> 这种形式,建议写明字段,这样可读性强.</p><h3 id="计算员工的年薪"><a href="#计算员工的年薪" class="headerlink" title="计算员工的年薪"></a>计算员工的年薪</h3><blockquote><p> 列出员工的编号，姓名和年薪</p></blockquote><p><code> select empno, ename, sal*12 from emp; </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165031.png" alt="image-20201218165355526"></p><p>在select语句中可以使用运算符，以上存在一些问题，年薪的字段名称不太明确</p><h3 id="将查询出来的字段显示为中文"><a href="#将查询出来的字段显示为中文" class="headerlink" title="将查询出来的字段显示为中文"></a>将查询出来的字段显示为中文</h3><p> <code>select empno as ‘员工编号’, ename as ‘员工姓名’, sal*12 as ‘年薪’ from emp;  </code></p><p>注意:字符串必须添加单引号 | 双引号  </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165029.png" alt="image-20201218165400868"></p><p>可以采用as关键字重命名表字段，其实as也可以省略，如：</p><p><code>select empno &quot;员工编号&quot;, ename &quot;员工姓名&quot;, sal*12 &quot;年薪&quot; from emp; </code> </p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>条件查询需要用到where语句，where必须放到from语句表的后面</p><p>支持如下运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;或!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>between … and ….</td><td>两个值之间,<strong>等同于 &gt;= and &lt;=</strong></td></tr><tr><td>is null</td><td>为null（is not null 不为空）</td></tr><tr><td><strong>and</strong></td><td>并且</td></tr><tr><td><strong>or</strong></td><td>或者</td></tr><tr><td>in</td><td>包含，相当于多个or（not in不在这个范围中）</td></tr><tr><td>not</td><td>not可以取非，主要用在is 或in中</td></tr><tr><td>like</td><td>like称为模糊查询，支持%或下划线匹配  %匹配任意个字符  下划线，一个下划线只匹配一个字符</td></tr></tbody></table><h3 id="等号操作符"><a href="#等号操作符" class="headerlink" title="等号操作符"></a>等号操作符</h3><blockquote><p>查询薪水为5000的员工</p></blockquote><p><code>select empno, ename, sal from  emp where sal=5000;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165024.png"></p><blockquote><p>查询job为MANAGER的员工</p></blockquote><p><code>select empno, ename from emp where job=manager;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165022.png" alt="image-20201218165419292"></p><p>以上查询出现错误，因为job为字符串，所以出现了以上错误</p><p><code>select empno, ename from emp where  job=&quot;manager&quot;; </code> </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165018.png" alt="image-20201218165510070"></p><p>`select empno, ename from emp where  job=’manager’;</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164852.png" alt="image-20201218165513311"></p><p>也可以使用单引号</p><p><code>select empno, ename from emp where  job=&#39;MANAGER&#39;;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164849.png" alt="image-20201218165539820"></p><p><code>以上输出正确，Mysql默认情况下大小写是不敏感的。</code></p><p>注意：</p><p>MySQL在windows下是不区分大小写的，将script文件导入MySQL后表名也会自动转化为小写，结果再想要将数据库导出放到linux服务器中使用时就出错了。因为在linux下表名区分大小写而找不到表，查了很多都是说在linux下更改MySQL的设置使其也不区分大小写，但是有没有办法反过来让windows 下大小写敏感呢。其实方法是一样的，相应的更改windows中MySQL的设置就行了。</p><p>​    具体操作：</p><p>​    在MySQL的配置文件my.ini中增加一行：</p><p>​    lower_case_table_names = 0</p><p>​    其中 0：区分大小写，1：不区分大小写</p><p>​    MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：</p><ol><li><p>数据库名与表名是严格区分大小写的；</p></li><li><p>表的别名是严格区分大小写的；</p></li><li><p>列名与列的别名在所有的情况下均是忽略大小写的；</p></li><li><p>变量名也是严格区分大小写的；  MySQL在Windows下都不区分大小写</p></li></ol><h3 id="lt-gt-操作符"><a href="#lt-gt-操作符" class="headerlink" title="&lt;&gt;操作符"></a>&lt;&gt;操作符</h3><blockquote><p>查询薪水不等于5000的员工</p></blockquote><p><code>select empno, ename, sal from emp where  sal &lt;&gt; 5000;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164846.png" alt="image-20201218165605090"></p><p>以下写法等同于以上写法，建议使用第一种写法</p><p><code>select empno, ename, sal from emp where  sal != 5000;  </code></p><p>数值也可以采用单引号引起来，如以下语句是正确的(不建议这么写)：</p><p><code>select empno, ename, sal from emp where  sal &lt;&gt; &#39;5000&#39;;  </code></p><blockquote><p>查询工作岗位不等于MANAGER的员工</p></blockquote><p><code>select empno, ename from emp where job  &lt;&gt; &#39;MANAGER&#39;;  </code></p><h3 id="between-…-and-…操作符"><a href="#between-…-and-…操作符" class="headerlink" title="between … and …操作符"></a>between … and …操作符</h3><blockquote><p>查询薪水为1600到3000的员工(第一种方式，采用&gt;=和&lt;=)</p></blockquote><p><code>select empno, ename, sal from emp where  sal &gt;= 1600 and sal &lt;= 3000;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164838.png" alt="image-20201218165625915"></p><blockquote><p>查询薪水为1600到3000的员工(第一种方式，采用between … and …)</p></blockquote><p><code>select empno, ename, sal from emp where  sal between 1600 and 3000;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164809.png"></p><p>关于between … and …，它是包含最大值和最小值的</p><h3 id="is-null"><a href="#is-null" class="headerlink" title="is null"></a>is null</h3><blockquote><p>Null为空，但不是空串，为null可以设置这个字段不填值，如果查询为null的字段，采用is null</p></blockquote><blockquote><p>查询津贴为空的员工</p></blockquote><p><code>select * from  emp where comm=null;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164815.png" alt="image-20201218165737664"></p><p><code>以上也无法查询出符合条件的数据，因为null类型比较特殊，必须使用 is来比较</code></p><p><code>select * from emp where comm is null;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231164819.png" alt="image-20201218165743049"></p><p>以上查询正确</p><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><strong>and表示并且的含义，表示所有的条件必须满足</strong></p><blockquote><p>工作岗位为MANAGER,薪水大于2500的员工</p></blockquote><p><code>select * from emp where job=&#39;MANAGER&#39; and  sal &gt; 2500;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165301.png" alt="image-20201218165851964"></p><h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p><strong>or，只要满足条件即可,相当于包含</strong></p><blockquote><p>查询出job为manager或者job为salesman的员工</p></blockquote><p><code>select * from emp where job=&#39;MANAGER&#39; or  job=&#39;SALESMAN&#39;; </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165306.png"></p><h3 id="表达式的优先级"><a href="#表达式的优先级" class="headerlink" title="表达式的优先级"></a>表达式的优先级</h3><blockquote><p>查询薪水大于1800，并且部门代码为20或30的员工（错误的写法）</p></blockquote><p><code>select * from emp where sal  &gt; 1800 and deptno = 20 or deptno = 30;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165310.png" alt="image-20201218170014126"></p><p>以上输出不是预期结果，薪水小于1800的数据也被查询上来了，原因是表达式的优先级导致的，首先过滤sal &gt; 1800 and deptno = 20，然后再将deptno = 30员工合并过来，所以是不对的</p><blockquote><p>查询薪水大于1800，并且部门代码为20或30的（正确的写法）</p></blockquote><p><code>select * from emp where sal &gt; 1800 and  (deptno = 20 or deptno = 30); </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165314.png" alt="image-20201218170019487"></p><p><code>关于运算符的问题：不用记，没有把握尽量采用括号</code></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p><strong>in表示包含的意思，完全可以采用or来表示，采用in会更简洁一些</strong></p><blockquote><p>查询出job为manager或者job为salesman的员工</p></blockquote><p><code>select * from emp where job in  (&#39;manager&#39;,&#39;salesman&#39;);  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165319.png" alt="image-20201218170128078"></p><blockquote><p>查询出薪水包含1600和薪水包含3000的员工</p></blockquote><p><code>select * from emp where sal in(1600,  3000);  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165326.png" alt="image-20201218170133180"></p><h3 id="not"><a href="#not" class="headerlink" title="not"></a>not</h3><blockquote><p>查询出薪水不包含1600和薪水不包含3000的员工（第一种写法）</p></blockquote><p><code>select * from emp where sal &lt;&gt; 1600  and sal &lt;&gt; 3000;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165329.png" alt="image-20201218170155208"></p><blockquote><p>查询出薪水不包含1600和薪水不包含3000的员工（第二种写法</p></blockquote><p><code>select * from emp where not (sal = 1600  or sal = 3000);  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165331.png" alt="image-20201218170211137"></p><blockquote><p>查询出薪水不包含1600和薪水不包含3000的员工（第三种写法）</p></blockquote><p><code>select * from emp where sal not in (1600,  3000); </code> </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165338.png" alt="image-20201218170226974"></p><blockquote><p>查询出津贴不为null的所有员工</p></blockquote><p>  <code>select * from emp where comm is not null;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165448.png" alt="image-20201231165448033"></p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p><strong>Like可以实现模糊查询，like支持%和下划线匹配</strong></p><blockquote><p>查询姓名以M开头所有的员工</p></blockquote><p><code>select * from emp where ename like &#39;M%&#39;;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165347.png" alt="image-20201218170259947"></p><blockquote><p>查询姓名以N结尾的所有的员工</p></blockquote><p><code>select * from emp where ename like &#39;%N&#39;;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165456.png" alt="image-20201218170303562"></p><blockquote><p>查询姓名中包含O的所有的员工</p></blockquote><p><code>select * from emp where ename like &#39;%O%&#39;;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165458.png" alt="image-20201218170316180"></p><blockquote><p>查询姓名中第二个字符为A的所有员工</p></blockquote><p><code>select * from emp where ename like &#39;_A%&#39;;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165501.png" alt="image-20201218170330393"></p><blockquote><p>Like中%和下划线的差别？</p></blockquote><p>%匹配任意字符出现的个数</p><blockquote><p>下划线只匹配一个字符</p></blockquote><p>Like 中的表达式必须放到单引号中|双引号中，以下写法是错误的：</p><p><del><code>select * from emp where  ename like _A%  </code></del></p><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><h3 id="单一字段排序"><a href="#单一字段排序" class="headerlink" title="单一字段排序"></a>单一字段排序</h3><p>排序采用order by子句，order by后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，<code>order by默认采用升序</code>，如果存在where子句那么order by必须放到where语句的后面</p><blockquote><p> 按照薪水由小到大排序(系统默认由小到大)</p></blockquote><p><code>select * from emp order by sal;  </code></p><p><img src="C:\Users\JiuYueSheng\AppData\Roaming\Typora\typora-user-images\image-20201218170932850.png" alt="image-20201218170932850"></p><blockquote><p>取得job为MANAGER的员工，按照薪水由小到大排序(系统默认由小到大)</p></blockquote><p><code>select * from emp where job=&#39;MANAGER&#39;  order by sal;  </code></p><p><img src="C:\Users\JiuYueSheng\AppData\Roaming\Typora\typora-user-images\image-20201218170949610.png" alt="image-20201218170949610"></p><p>如果包含where语句order by必须放到where后面，如果没有where语句order by放到表的后面</p><p>以下写法是错误的：</p><p><del><code>select * from emp order  by sal where job=&#39;MANAGER&#39;;  </code></del></p><blockquote><p>按照多个字段排序，如：首先按照job排序，再按照sal排序</p></blockquote><p><code>select * from emp order by job,sal;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165510.png" alt="image-20201218171022163"></p><h3 id="手动指定排序顺序"><a href="#手动指定排序顺序" class="headerlink" title="手动指定排序顺序"></a>手动指定排序顺序</h3><blockquote><p>手动指定按照薪水由小到大排序</p></blockquote><p><code>select * from emp order by sal asc;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165513.png" alt="image-20201218171050416"></p><blockquote><p>手动指定按照薪水由大到小排序</p></blockquote><p><code>select * from emp order by sal desc;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165520.png" alt="image-20201218171054348"></p><h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><blockquote><p>按照job和薪水倒序</p></blockquote><p><code>select * from emp order by job desc, sal desc;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165528.png" alt="image-20201218171138249"></p><p>如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序</p><h3 id="使用字段的位置来排序"><a href="#使用字段的位置来排序" class="headerlink" title="使用字段的位置来排序"></a>使用字段的位置来排序</h3><blockquote><p>按照薪水升序</p></blockquote><p><code>select * from emp order by 6;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165531.png" alt="image-20201218171146328"></p><p><code>不建议使用此种方式，采用数字含义不明确，程序不健壮</code></p><h2 id="分组函数-聚合函数-多行处理函数"><a href="#分组函数-聚合函数-多行处理函数" class="headerlink" title="分组函数/聚合函数/多行处理函数"></a>分组函数/聚合函数/多行处理函数</h2><table><thead><tr><th>count</th><th>取得记录数</th></tr></thead><tbody><tr><td>sum</td><td>求和</td></tr><tr><td>avg</td><td>取平均</td></tr><tr><td>max</td><td>取最大的数</td></tr><tr><td>min</td><td>取最小的数</td></tr></tbody></table><p><strong>注意：分组函数自动忽略空值，不需要手动的加where</strong> <strong>条件排除空值。</strong></p><p><strong>select count(*) from emp where xxx;</strong>            <strong>符合条件的所有记录总数。</strong></p><p><strong>select count(comm) from emp;     comm</strong> <strong>这个字段中不为空的元素总数。</strong></p><p><code>注意：分组函数不能直接使用在where关键字后面。</code></p><p>mysql&gt; <code>select ename,sal from emp where sal &gt; avg(sal);</code></p><p>ERROR 1111 (HY000): Invalid use of group function</p><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><blockquote><p>取得所有的员工数</p></blockquote><p><code>select count(*) from emp; </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165539.png" alt="image-20201218173940299"></p><p>Count(*)表示取得所有记录，忽略null，为null的值也会取得</p><blockquote><p>取得津贴不为null员工数</p></blockquote><p><code>select count(comm) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165541.png"></p><p><code>采用count(字段名称)，不会取得为null的记录</code></p><blockquote><p>取得工作岗位的个数</p></blockquote><p><code>select count(distinct  job) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165544.png" alt="image-20201218173949903"></p><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><p><strong>Sum可以取得某一个列的和，null会被忽略</strong></p><blockquote><p>取得薪水的合计</p></blockquote><p><code>select sum(sal) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165551.png" alt="image-20201218174438539"></p><blockquote><p>取得津贴的合计</p></blockquote><p><code>select sum(comm) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165556.png" alt="img"></p><p>null会被忽略</p><blockquote><p>取得薪水的合计（sal+comm）</p></blockquote><p><code>select sum(sal+comm) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165600.png" alt="image-20201218174445799"></p><p>从以上结果来看，不正确，原因在于comm字段有null值，所以无法计算，sum会忽略掉，正确的做法是将comm字段转换成0</p><p><code>select sum(sal+IFNULL(comm, 0)) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165604.png" alt="image-20201218174449585"></p><h3 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h3><p><strong>取得某一列的平均值</strong></p><blockquote><p>取得平均薪水</p></blockquote><p><code>select avg(sal) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165612.png" alt="image-20201218174659078"></p><h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><p><strong>取得某个一列的最大值</strong></p><blockquote><p>取得最高薪水</p></blockquote><p><code>select max(sal) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165616.png" alt="image-20201218174703186"></p><blockquote><p>取得最晚入职得员工</p></blockquote><p><code>select max(str_to_date (hiredate, &#39;%Y-%m-%d&#39;))  from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165620.png"></p><h3 id="min"><a href="#min" class="headerlink" title="min"></a>min</h3><p><strong>取得某个一列的最小值</strong></p><blockquote><p>取得最低薪水</p></blockquote><p><code>select min(sal) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165625.png" alt="image-20201218174712015"></p><blockquote><p>取得最早入职得员工（可以不使用str_to_date转换）</p></blockquote><p><code>select min(str_to_date(hiredate, &#39;%Y-%m-%d&#39;))  from emp; </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165630.png" alt="image-20201218174715995"></p><h3 id="组合聚合函数"><a href="#组合聚合函数" class="headerlink" title="组合聚合函数"></a>组合聚合函数</h3><p>可以将这些聚合函数都放到select中一起使用</p><p><code>select  count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165634.png" alt="image-20201218174731029"></p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询主要涉及到两个子句，分别是：group by和having</p><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><blockquote><p>取得每个工作岗位的工资合计，要求显示岗位名称和工资合计</p></blockquote><p><code>select job, sum(sal) from emp group by  job;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165637.png" alt="image-20201218175317230"></p><p><code>如果使用了order by，order by必须放到group by后面</code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165639.png" alt="image-20201218175322585"></p><blockquote><p>按照工作岗位和部门编码分组，取得的工资合计</p></blockquote><p><strong>原始数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165643.png" alt="image-20201218175326673"></p><p> <strong>分组语句</strong></p><p><code>select job,deptno,sum(sal) from emp group  by job,deptno;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165646.png" alt="image-20201218175353995"></p><p>mysql&gt; <code>select empno,deptno,avg(sal) from emp group by deptno;</code></p><p>以上SQL语句在Oracle数据库中无法执行，执行报错。</p><p>以上SQL语句在Mysql数据库中可以执行，但是执行结果矛盾。</p><p>在SQL语句中若有group by 语句，那么在select语句后面只能跟<strong>分组函数</strong> + <strong>参与分组的字段</strong>。</p><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p><strong>如果想对分组数据再进行过滤需要使用having子句</strong></p><blockquote><p>取得每个岗位的平均工资大于2000</p></blockquote><p><code>select job, avg(sal) from emp group by  job having avg(sal) &gt;2000;</code>  </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165651.png"></p><p>分组函数的执行顺序：</p><ul><li>根据条件查询数据</li><li>分组</li><li>采用having过滤，取得正确的数据</li></ul><h3 id="select语句总结"><a href="#select语句总结" class="headerlink" title="select语句总结"></a>select语句总结</h3><p>一个完整的select语句格式如下</p><p>select 字段  from 表名  where …  group by … having …(就是为了过滤分组后的数据而存在的—不可以单独的出现)  order by …</p><p>以上语句的执行顺序</p><ol><li>首先执行where语句过滤原始数据</li><li>执行group by进行分组</li><li>执行having对分组数据进行操作</li><li>执行select选出数据</li><li>执行order by排序</li></ol><p><code>原则：能在where中过滤的数据，尽量在where中过滤，效率较高。having的过滤是专门对分组之后的数据进行过滤的。</code></p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="SQL92语法"><a href="#SQL92语法" class="headerlink" title="SQL92语法"></a>SQL92语法</h3><p><strong>连接查询：也可以叫跨表查询，需要关联多个表进行查询</strong></p><blockquote><p>显示每个员工信息，并显示所属的部门名称</p></blockquote><p><code> select ename, dname from emp, dept; </code></p><p>以上输出，不正确，输出了56条数据，其实就是两个表记录的成绩，这种情况我们称为：“笛卡儿乘积”，出现错误的原因是：没有指定连接条件</p><p>指定连接条件</p><p><code>select emp.ename, dept.dname from emp,  dept where emp.deptno=dept.deptno;  </code></p><p>也可以使用别名</p><p><code>select e.ename, d.dname from emp e, dept  d where e.deptno=d.deptno;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165655.png" alt="image-20201218234415319"></p><p>以上结果输出正确，因为加入了正确的连接条件</p><p>以上查询也称为 “内连接”，只查询相等的数据（连接条件相等的数据）</p><blockquote><p>取得员工和所属的领导的姓名</p></blockquote><p><code> select e.ename, m.ename from emp e, emp m  where e.mgr=m.empno; </code></p><p>以上称为“自连接”，只有一张表连接，具体的查询方法，把一张表看作两张表即可，如以上示例：第一个表emp e代码了员工表，emp m代表了领导表，相当于员工表和部门表一样</p><h3 id="SQL99语法"><a href="#SQL99语法" class="headerlink" title="SQL99语法"></a>SQL99语法</h3><blockquote><p>(内连接)显示薪水大于2000的员工信息，并显示所属的部门名称</p></blockquote><p>采用SQL92语法：  </p><p><code>select e.ename, e.sal, d.dname from emp  e, dept d where e.deptno=d.deptno and   e.sal &gt; 2000;  </code></p><p>采用SQL99语法：  </p><p><code>select e.ename, e.sal, d.dname from emp e  join dept d on e.deptno=d.deptno where e.sal&gt;2000; </code> </p><p>或  </p><p><code>select e.ename, e.sal, d.dname from emp e  inner join dept d on e.deptno=d.deptno where  e.sal&gt;2000;</code></p><p>  在实际中一般不加inner关键字  </p><p><code>Sql92语法和sql99语法的区别：99语法可以做到表的连接和查询条件分离，特别是多个表进行连接的时候，会比sql92更清晰</code></p><blockquote><p>(外连接）显示员工信息，并显示所属的部门名称，如果某一个部门没有员工，那么该部门也必须显示出来</p></blockquote><p> 右连接：  </p><p><code>select e.ename, e.sal, d.dname from emp e  right join dept d on e.deptno=d.deptno; </code></p><p> 左连接：  </p><p><code>select e.ename, e.sal, d.dname from dept  d left join emp e on e.deptno=d.deptno;</code></p><p> 以上两个查询效果相同  </p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165659.png" alt="image-20201218234405790"></p><p>连接分类：</p><p>内链接</p><p>* 表1 inner join 表2 on 关联条件</p><p>* 做连接查询的时候一定要写上关联条件</p><p>* inner 可以省略</p><p>外连接</p><ol><li><p>左外连接</p><ul><li><p>表1 left outer join 表2 on 关联条件</p></li><li><p>做连接查询的时候一定要写上关联条件</p></li><li><p>outer 可以省略</p></li></ul></li><li><p>右外连接</p><ul><li>表1 right outer join 表2 on 关联条件</li><li>做连接查询的时候一定要写上关联条件</li><li>outer 可以省略</li></ul></li></ol><p>*左外连接（左连接）和右外连接（右连接）的区别：</p><p>*左连接以左面的表为准和右边的表比较，和左表相等的不相等都会显示出来，右表符合条件的显示,不符合条件的不显示</p><p>*右连接恰恰相反，以上左连接和右连接也可以加入outer关键字，但一般不建议这种写法，如：</p><p><code>select e.ename, e.sal, d.dname from emp e  right outer join dept d on e.deptno=d.deptno; </code></p><p><code>select e.ename, e.sal, d.dname from dept  d left outer join emp e on e.deptno=d.deptno;  </code></p><p>左连接能完成的功能右连接一定可以完成</p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165704.png" alt="image-20201218234357234"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>子查询就是嵌套的select语句，可以理解为子查询是一张表</strong></p><h3 id="在where语句中使用子查询，也就是在where语句中加入select语句"><a href="#在where语句中使用子查询，也就是在where语句中加入select语句" class="headerlink" title="在where语句中使用子查询，也就是在where语句中加入select语句"></a>在where语句中使用子查询，也就是在where语句中加入select语句</h3><blockquote><p>查询员工信息，查询哪些人是管理者，要求显示出其员工编号和员工姓名</p></blockquote><p>实现思路：</p><ol><li><p>首先取得管理者的编号，去除重复的</p><p><code>select distinct mgr from emp where mgr is  not null;</code>     distinct 去除重复行  </p></li><li><p>查询员工编号包含管理者编号的</p><p><code>select empno, ename from emp where empno  in(select mgr from emp where mgr is not null);  </code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165708.png" alt="image-20201219001553937"></p><blockquote><p>查询哪些人的薪水高于员工的平均薪水，需要显示员工编号，员工姓名，薪水</p></blockquote><p>实现思路</p><ol><li><p>取得平均薪水</p><p><code>select avg(sal) from emp;  </code></p></li><li><p>取得大于平均薪水的员工</p><p><code>select empno, ename, sal from emp where  sal &gt; (select avg(sal) from emp); </code></p></li></ol><p>​     <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165713.png" alt="image-20201219001558957"></p><h3 id="在from语句中使用子查询，可以将该子查询看做一张表"><a href="#在from语句中使用子查询，可以将该子查询看做一张表" class="headerlink" title="在from语句中使用子查询，可以将该子查询看做一张表"></a>在from语句中使用子查询，可以将该子查询看做一张表</h3><blockquote><p>查询员工信息，查询哪些人是管理者，要求显示出其员工编号和员工姓名</p></blockquote><ol><li><p>首先取得管理者的编号，去除重复的</p><p><code>select distinct mgr from emp where mgr is  not null;  </code></p></li><li><p>将以上查询作为一张表，放到from语句的后面</p><p>使用92语法：  </p><p><code>select e.empno, e.ename from emp e,  </code></p><p><code>(select distinct mgr from emp where mgr is not null) m where e.empno=m.mgr; </code></p><p>使用99语法：  </p></li></ol><p><code>select e.empno, e.ename from emp e join  (select distinct mgr from emp where mgr is not null) m on e.empno=m.mgr;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165720.png" alt="image-20201219001605486"></p><blockquote><p>查询各个部门的平均薪水所属等级，需要显示部门编号，平均薪水，等级编号</p></blockquote><p>实现思路</p><p>1、首先取得各个部门的平均薪水</p><p>  <code>select deptno, avg(sal) avg_sal from emp group by deptno;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165754.png" alt="image-20201219001609156"></p><p>2、将部门的平均薪水作为一张表与薪水等级表建立连接，取得等级</p><p><code>select deptno,avg(sal) avg_sal from emp  group by deptno; </code></p><p><code>select * from salgrade; </code></p><p><code> select a.deptno,a.avg_sal,g.grade from  (select deptno,avg(sal) avg_sal from emp group by deptno ) a join salgrade g  on a.avg_sal between g.losal and hisal; </code>                                    <img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165725.png" alt="image-20201219001727120"></p><h3 id="在select语句中使用子查询"><a href="#在select语句中使用子查询" class="headerlink" title="在select语句中使用子查询"></a>在select语句中使用子查询</h3><blockquote><p>查询员工信息，并显示出员工所属的部门名称</p></blockquote><p>第一种做法，将员工表和部门表连接</p><p><code>select e.ename, d.dname from emp e, dept  d where e.deptno=d.deptno; </code></p><p>第二种做法，在select语句中再次嵌套select语句完成部分名称的查询</p><p><code>select e.ename, (select d.dname from dept  d where e.deptno=d.deptno) as dname from emp e;  </code></p><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165732.png" alt="image-20201219002430507"></p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><h3 id="union可以合并集合（相加）"><a href="#union可以合并集合（相加）" class="headerlink" title="union可以合并集合（相加）"></a>union可以合并集合（相加）</h3><ol><li><p>查询job包含MANAGER和包含SALESMAN的员工</p><p><code>select * from emp where job in(&#39;MANAGER&#39;,  &#39;SALESMAN&#39;);  </code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/20201231165738.png" alt="image-20201219002609549"></p><ol start="2"><li><p>采用union来合并</p><p><code>select * from emp where job=&#39;MANAGER&#39;  union  select * from emp where job=&#39;SALESMAN&#39;  </code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ityoung09/image@main/image-20201219002615091.png" alt="image-20201219002615091"></p><p><code>合并结果集的时候，需要查询字段对应个数相同。*在**Oracle**中更严格，不但要求个数相同，而且还要求类型对应相同*。</code></p><h2 id="limit-的使用"><a href="#limit-的使用" class="headerlink" title="limit 的使用"></a>limit 的使用</h2><p>MySQL提供了<code>limit</code> ，主要用于提取前几条或者中间某几行数据</p><p><code>select * from table limit m,n</code>  </p><p>其中m是指记录开始的index，从0开始,表示第一条记录<br>n是指从第m+1条开始，取n条。<br><code>select * from tablename limit 2,4</code><br>即取出第3条至第6条，4条记录</p><h3 id="取得前5条数据"><a href="#取得前5条数据" class="headerlink" title="取得前5条数据"></a>取得前5条数据</h3><p>  <code>select * from emp limit 5;</code></p><h3 id="从第二条开始取两条数据"><a href="#从第二条开始取两条数据" class="headerlink" title="从第二条开始取两条数据"></a>从第二条开始取两条数据</h3><p> <code>select * from emp limit 1,2;  </code></p><h3 id="取得薪水最高的前5名"><a href="#取得薪水最高的前5名" class="headerlink" title="取得薪水最高的前5名"></a>取得薪水最高的前5名</h3><p><code>select  * from emp e order by e.sal desc limit 5;  </code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库概述及数据准备&quot;&gt;&lt;a href=&quot;#数据库概述及数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据库概述及数据准备&quot;&gt;&lt;/a&gt;数据库概述及数据准备&lt;/h2&gt;&lt;h3 id=&quot;SQL概述&quot;&gt;&lt;a href=&quot;#SQL概述&quot; class=&quot;he</summary>
      
    
    
    
    <category term="MySQL" scheme="http://www.ityoung.xyz/categories/MySQL/"/>
    
    
    <category term="StudyNote" scheme="http://www.ityoung.xyz/tags/StudyNote/"/>
    
    <category term="SQL" scheme="http://www.ityoung.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.ityoung.xyz/posts/16107/"/>
    <id>http://www.ityoung.xyz/posts/16107/</id>
    <published>2020-12-21T08:04:27.119Z</published>
    <updated>2020-12-26T08:48:41.757Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
